# X509 Module

X509 certificate handling for PKI operations.

## Overview

The X509 module provides safe certificate generation, parsing, and validation using `rcgen` for generation and `x509-parser` for parsing. All operations use pure Rust implementations - no OpenSSL.

## Concepts

### Certificate Types

| Type | Description | Use Case |
|------|-------------|----------|
| Self-signed | Signed by own key | Development, testing |
| CA certificate | Certificate Authority | Signing other certs |
| End-entity | Signed by CA | Servers, clients |
| CSR | Certificate Signing Request | Request CA signature |

### Key Types

| Algorithm | Sizes | Notes |
|-----------|-------|-------|
| RSA | 2048, 4096 | Wide compatibility |
| ECDSA P-256 | 256-bit | Modern, efficient |
| ECDSA P-384 | 384-bit | Higher security |
| Ed25519 | 256-bit | Fastest, modern |

## API Reference

### Key Generation

```rust
/// Generate an RSA key pair (returns PEM)
pub fn keypair_generate_rsa(bits: u32) -> WrapperResult<OwnedBuffer>;

/// Generate an EC key pair (P-256, P-384, or P-521)
pub fn keypair_generate_ec(curve: &str) -> WrapperResult<OwnedBuffer>;

/// Generate an Ed25519 key pair
pub fn keypair_generate_ed25519() -> WrapperResult<OwnedBuffer>;
```

### Certificate Creation

```rust
/// Create a self-signed certificate
pub fn create_self_signed(
    subject: &str,
    keypair_pem: &OwnedBuffer,
    days: u32,
) -> WrapperResult<OwnedBuffer>;

/// Create a Certificate Signing Request (CSR)
pub fn create_csr(
    subject: &str,
    keypair_pem: &OwnedBuffer,
) -> WrapperResult<OwnedBuffer>;

/// Sign a CSR with a CA certificate
pub fn sign_csr(
    csr_pem: &OwnedBuffer,
    ca_cert_pem: &OwnedBuffer,
    ca_key_pem: &OwnedBuffer,
    days: u32,
) -> WrapperResult<OwnedBuffer>;

/// Create a CA certificate (with basicConstraints CA:TRUE)
pub fn create_ca(
    subject: &str,
    keypair_pem: &OwnedBuffer,
    days: u32,
) -> WrapperResult<OwnedBuffer>;
```

### Certificate Parsing

```rust
/// Parse a PEM-encoded certificate
pub fn parse_pem(cert_pem: &OwnedBuffer) -> WrapperResult<CertInfo>;

/// Parse a DER-encoded certificate
pub fn parse_der(cert_der: &OwnedBuffer) -> WrapperResult<CertInfo>;

/// Convert PEM to DER
pub fn pem_to_der(pem: &OwnedBuffer) -> WrapperResult<OwnedBuffer>;

/// Convert DER to PEM
pub fn der_to_pem(der: &OwnedBuffer) -> WrapperResult<OwnedBuffer>;
```

### Certificate Information

```rust
/// Certificate information structure
pub struct CertInfo {
    pub subject: String,
    pub issuer: String,
    pub serial: String,
    pub not_before: String,
    pub not_after: String,
    pub is_ca: bool,
    pub key_usage: Vec<String>,
    pub san: Vec<String>,  // Subject Alternative Names
}

/// Get certificate subject
pub fn get_subject(cert_pem: &OwnedBuffer) -> WrapperResult<OwnedBuffer>;

/// Get certificate issuer
pub fn get_issuer(cert_pem: &OwnedBuffer) -> WrapperResult<OwnedBuffer>;

/// Get certificate serial number (hex)
pub fn get_serial(cert_pem: &OwnedBuffer) -> WrapperResult<OwnedBuffer>;

/// Get certificate expiry as ISO timestamp
pub fn get_expiry(cert_pem: &OwnedBuffer) -> WrapperResult<OwnedBuffer>;

/// Check if certificate is expired
pub fn is_expired(cert_pem: &OwnedBuffer) -> WrapperResult<bool>;

/// Get days until expiry
pub fn days_until_expiry(cert_pem: &OwnedBuffer) -> WrapperResult<i64>;
```

### Verification

```rust
/// Verify certificate signature against issuer
pub fn verify(cert_pem: &OwnedBuffer, issuer_pem: &OwnedBuffer) -> WrapperResult<bool>;

/// Verify certificate chain
pub fn verify_chain(
    cert_pem: &OwnedBuffer,
    chain_pems: &[OwnedBuffer],
) -> WrapperResult<bool>;

/// Extract public key from certificate (PEM)
pub fn get_public_key(cert_pem: &OwnedBuffer) -> WrapperResult<OwnedBuffer>;
```

## Usage Examples

### Generate Self-Signed Certificate

```rust
use neurlang::wrappers::{OwnedBuffer, x509};

// Generate key pair
let keypair = x509::keypair_generate_ec("P-256")?;

// Create self-signed certificate
let cert = x509::create_self_signed(
    "CN=localhost,O=Test",
    &keypair,
    365,  // days
)?;

println!("Certificate:\n{}", cert.as_str().unwrap());
```

### Create CA and Sign Certificates

```rust
// Create CA
let ca_key = x509::keypair_generate_rsa(4096)?;
let ca_cert = x509::create_ca(
    "CN=My CA,O=My Organization",
    &ca_key,
    3650,  // 10 years
)?;

// Create server CSR
let server_key = x509::keypair_generate_ec("P-256")?;
let csr = x509::create_csr(
    "CN=server.example.com",
    &server_key,
)?;

// Sign with CA
let server_cert = x509::sign_csr(
    &csr,
    &ca_cert,
    &ca_key,
    365,
)?;

// Verify chain
let valid = x509::verify(&server_cert, &ca_cert)?;
assert!(valid);
```

### Parse and Inspect Certificate

```rust
let cert_pem = OwnedBuffer::from_str(include_str!("cert.pem"));

// Parse full info
let info = x509::parse_pem(&cert_pem)?;
println!("Subject: {}", info.subject);
println!("Issuer: {}", info.issuer);
println!("Valid until: {}", info.not_after);
println!("Is CA: {}", info.is_ca);
println!("SANs: {:?}", info.san);

// Check expiry
if x509::is_expired(&cert_pem)? {
    println!("Certificate is EXPIRED!");
} else {
    let days = x509::days_until_expiry(&cert_pem)?;
    println!("Expires in {} days", days);
}
```

### Certificate Chain Verification

```rust
// Load certificate and chain
let server_cert = load_cert("server.pem");
let intermediate = load_cert("intermediate.pem");
let root = load_cert("root.pem");

// Verify chain
let chain = vec![intermediate, root];
let valid = x509::verify_chain(&server_cert, &chain)?;

if valid {
    println!("Certificate chain is valid");
} else {
    println!("Certificate chain verification FAILED");
}
```

## IR Assembly Usage

```asm
; Generate EC key pair
mov r1, curve_ptr    ; "P-256"
ext.call r0, @"keypair generate ec", r1

; Create self-signed cert
mov r1, subject_ptr  ; "CN=localhost"
mov r2, keypair_ptr
mov r3, 365          ; days
ext.call r0, @"x509 create self-signed", r1, r2, r3

; Parse certificate
mov r1, cert_pem_ptr
ext.call r0, @"x509 parse", r1

; Get expiry
mov r1, cert_pem_ptr
ext.call r0, @"x509 get expiry", r1

; Verify
mov r1, cert_ptr
mov r2, issuer_ptr
ext.call r0, @"x509 verify", r1, r2
; r0 = 1 if valid, 0 if not
```

## RAG Keywords

| Intent | Resolves To |
|--------|-------------|
| "generate keypair", "create key", "keygen" | `keypair_generate_*` |
| "self-signed", "create cert", "generate certificate" | `create_self_signed` |
| "csr", "certificate request", "signing request" | `create_csr` |
| "sign csr", "issue certificate" | `sign_csr` |
| "parse cert", "read certificate", "decode x509" | `parse_pem` |
| "verify cert", "validate certificate" | `verify` |
| "cert expiry", "when expires", "is expired" | `is_expired` / `get_expiry` |
| "ca", "certificate authority" | `create_ca` |

## Error Handling

```rust
use neurlang::wrappers::{WrapperError, x509};

match x509::parse_pem(&cert_data) {
    Ok(info) => {
        println!("Subject: {}", info.subject);
    }
    Err(WrapperError::X509Error(msg)) => {
        // Invalid certificate format
        eprintln!("X509 error: {}", msg);
    }
    Err(WrapperError::InvalidArg(msg)) => {
        // Bad parameter (e.g., unsupported curve)
        eprintln!("Invalid argument: {}", msg);
    }
    Err(e) => {
        eprintln!("Unexpected error: {}", e);
    }
}
```

Common errors:
- `X509Error("invalid PEM")` - Not valid PEM format
- `X509Error("certificate parsing failed")` - Invalid certificate structure
- `X509Error("signature verification failed")` - Cert not signed by issuer
- `InvalidArg("unsupported curve")` - Unknown EC curve name

## Subject Name Format

Subject names use the X.500 Distinguished Name format:

| Attribute | Abbreviation | Example |
|-----------|--------------|---------|
| Common Name | CN | CN=www.example.com |
| Organization | O | O=Example Inc |
| Organizational Unit | OU | OU=IT Department |
| Country | C | C=US |
| State/Province | ST | ST=California |
| Locality | L | L=San Francisco |

Example: `CN=www.example.com,O=Example Inc,C=US`

## Dependencies

```toml
[dependencies]
rcgen = "0.12"           # Certificate generation
x509-parser = "0.16"     # Certificate parsing
```

## Security Considerations

### Key Storage

- **Never log private keys**
- Store keys encrypted at rest
- Use appropriate file permissions (0600)

### Certificate Validity

- Check expiry before using certificates
- Implement certificate rotation
- Monitor for certificate expiration

### Key Sizes

| Algorithm | Minimum | Recommended |
|-----------|---------|-------------|
| RSA | 2048 | 4096 |
| ECDSA | P-256 | P-256 or P-384 |
| Ed25519 | N/A | N/A (fixed size) |

## See Also

- [Buffer Module](buffer.md) - OwnedBuffer type
- [TLS Module](tls.md) - Using certificates for TLS connections
- [Crypto Extensions](../extensions/bundled.md) - Low-level crypto operations
