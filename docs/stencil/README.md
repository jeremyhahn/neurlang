# Stencil System

Pre-compiled code templates for copy-and-patch compilation.

## Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│                     Stencil System                                   │
└─────────────────────────────────────────────────────────────────────┘

  Build Time                              Runtime
  ┌─────────────┐                        ┌─────────────┐
  │ C Source    │                        │ IR Opcode   │
  │ with inline │                        └──────┬──────┘
  │ assembly    │                               │
  └──────┬──────┘                               ▼
         │                               ┌─────────────┐
         ▼                               │  Table      │
  ┌─────────────┐                        │  Lookup     │
  │ Compile to  │                        └──────┬──────┘
  │ .o file     │                               │
  └──────┬──────┘                               ▼
         │                               ┌─────────────┐
         ▼                               │  Stencil    │────▶ Machine
  ┌─────────────┐                        │  Entry      │      Code
  │ Extract     │────────────────────────▶             │
  │ machine     │   Embedded in binary   └─────────────┘
  │ code bytes  │
  └─────────────┘
```

## Stencil Structure

```rust
pub struct StencilEntry {
    /// Raw machine code bytes
    pub code: Vec<u8>,
    /// Patch locations and types
    pub patches: Vec<PatchInfo>,
    /// Size in bytes
    pub size: usize,
}

pub struct PatchInfo {
    /// Byte offset in stencil
    pub offset: usize,
    /// What to patch
    pub kind: PatchKind,
}

pub enum PatchKind {
    DstReg,      // Destination register index
    Src1Reg,     // Source 1 register index
    Src2Reg,     // Source 2 register index
    Imm32,       // 32-bit immediate
    Imm64,       // 64-bit immediate
    BranchTarget, // Branch offset
}
```

## Stencil Table Layout

```
┌─────────────────────────────────────────────────────────────────────┐
│                     Stencil Table                                    │
└─────────────────────────────────────────────────────────────────────┘

  Index = (opcode << 3) | mode

  ┌───────┬──────────┬────────────────────────────────────────────────┐
  │ Index │ Opcode   │ Stencil                                        │
  ├───────┼──────────┼────────────────────────────────────────────────┤
  │   0   │ ALU.ADD  │ StencilEntry { code: [...], patches: [...] }   │
  │   1   │ ALU.SUB  │ StencilEntry { code: [...], patches: [...] }   │
  │   2   │ ALU.AND  │ StencilEntry { code: [...], patches: [...] }   │
  │  ...  │   ...    │ ...                                            │
  │  184  │ HALT     │ StencilEntry { code: [0x48, 0xb8, ...], ... }  │
  └───────┴──────────┴────────────────────────────────────────────────┘
```

## Stencil Code Example

### ADD Stencil (x86-64)

```asm
; Stencil for: add rd, rs1, rs2
; Convention: RDI = pointer to register file

; Load src1
movabs rax, PLACEHOLDER_SRC1    ; 48 b8 [8 bytes placeholder]
mov    rax, [rdi + rax*8]       ; Load register value

; Load src2
movabs rcx, PLACEHOLDER_SRC2    ; 48 b9 [8 bytes placeholder]
mov    rcx, [rdi + rcx*8]       ; Load register value

; Perform operation
add    rax, rcx                  ; The actual add

; Store result
movabs rcx, PLACEHOLDER_DST     ; 48 b9 [8 bytes placeholder]
mov    [rdi + rcx*8], rax       ; Store to destination

ret                              ; Return to dispatcher
```

### Generated Bytes

```
48 b8 22 22 22 22 22 22 22 22   ; movabs rax, PLACEHOLDER_SRC1
48 8b 04 c7                     ; mov rax, [rdi + rax*8]
48 b9 33 33 33 33 33 33 33 33   ; movabs rcx, PLACEHOLDER_SRC2
48 8b 0c cf                     ; mov rcx, [rdi + rcx*8]
48 01 c8                        ; add rax, rcx
48 b9 11 11 11 11 11 11 11 11   ; movabs rcx, PLACEHOLDER_DST
48 89 04 cf                     ; mov [rdi + rcx*8], rax
c3                              ; ret
```

## Build Process

```
┌─────────────────────────────────────────────────────────────────────┐
│                    build.rs Flow                                     │
└─────────────────────────────────────────────────────────────────────┘

  1. Generate C source with inline assembly
     ┌──────────────────────────────────────────────────────────────┐
     │ __attribute__((naked, noinline))                             │
     │ void stencil_alu_add(void) {                                 │
     │     __asm__ volatile(                                        │
     │         "movq $0xDEADBEEF22222222, %%rax\n"                  │
     │         ...                                                   │
     │     );                                                        │
     │ }                                                             │
     └──────────────────────────────────────────────────────────────┘
                            │
                            ▼
  2. Compile to object file
     ┌──────────────────────────────────────────────────────────────┐
     │ cc -c -O2 -fno-stack-protector stencils.c -o stencils.o     │
     └──────────────────────────────────────────────────────────────┘
                            │
                            ▼
  3. Extract machine code
     ┌──────────────────────────────────────────────────────────────┐
     │ objdump -t -d stencils.o | parse symbols and code           │
     └──────────────────────────────────────────────────────────────┘
                            │
                            ▼
  4. Generate Rust module
     ┌──────────────────────────────────────────────────────────────┐
     │ pub static ALU_ADD_CODE: [u8; 43] = [...];                  │
     │ pub static ALU_ADD_PATCHES: [(usize, u8); 3] = [...];       │
     └──────────────────────────────────────────────────────────────┘
```

## Fallback Stencils

When build-time compilation fails, hand-coded fallback stencils are used:

```rust
// Hand-coded x86-64 stencils
pub static ALU_ADD_CODE: [u8; 43] = [
    0x48, 0xb8, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
    0x48, 0x8b, 0x04, 0xc7,
    0x48, 0xb9, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
    0x48, 0x8b, 0x0c, 0xcf,
    0x48, 0x01, 0xc8,
    0x48, 0xb9, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
    0x48, 0x89, 0x04, 0xcf,
    0xc3,
];
```

## Multi-Architecture Support

```
┌─────────────────────────────────────────────────────────────────────┐
│                 Architecture-Specific Stencils                       │
└─────────────────────────────────────────────────────────────────────┘

  Same IR, different stencil tables:

  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐
  │   x86-64     │    │   ARM64      │    │   RISC-V     │
  │   ~30KB      │    │   ~25KB      │    │   ~20KB      │
  └──────────────┘    └──────────────┘    └──────────────┘
         │                   │                   │
         └───────────────────┴───────────────────┘
                             │
                             ▼
                    ┌──────────────┐
                    │  Same IR     │
                    │  Different   │
                    │  code gen    │
                    └──────────────┘
```

## Usage

```rust
use neurlang::stencil::{StencilTable, patch_stencil};

// Create table
let table = StencilTable::new();

// Lookup stencil
let stencil = table.get(Opcode::Alu, AluOp::Add as u8).unwrap();

// Patch for specific instruction
let mut output = vec![0u8; stencil.size];
patch_stencil(stencil, &instruction, &mut output);
```

---

## What Gets Inlined

The stencil system determines what code is directly inlined versus calling runtime functions.

### Fully Inlined (No Runtime Call)

These operations are 100% generated as inline native code:

| Operation | Stencil Size | x86-64 Instructions |
|-----------|--------------|---------------------|
| ALU (add, sub, etc.) | 30-40 bytes | 4-6 instructions |
| Memory load/store | 50-70 bytes | 8-12 instructions (with bounds check) |
| Branches and jumps | 15-25 bytes | 2-4 instructions |
| Register moves | 20-30 bytes | 3-4 instructions |
| Atomic operations | 25-35 bytes | 4-5 instructions |
| Bit manipulation | 25-40 bytes | 3-6 instructions |

### Runtime Calls (Not Inlined)

These operations generate a `call` instruction to the runtime library:

| Operation | Why Not Inlined |
|-----------|-----------------|
| FILE.* | Complex OS syscalls, sandboxing logic |
| NET.* | Socket management, error handling |
| SPAWN/JOIN | Task scheduler interaction |
| CHAN.* | Lock-free queue implementation |
| CAP_NEW | Security context creation |

---

## Example: LOAD with Bounds Check

Neurlang provides implicit memory safety through fat pointers. Every memory access is bounds-checked, but the check is inlined for performance.

### Neurlang Instruction

```
LOAD.D r1, [r2]      ; Load 64-bit value from address in r2
```

### Fat Pointer Format

```
Register r2 contains a fat pointer:
┌──────────┬──────────┬──────────┬──────────┬──────────────────────┐
│  TAG     │  TAINT   │  PERMS   │  LENGTH  │       BASE           │
│  4 bits  │  4 bits  │  8 bits  │  16 bits │      32 bits         │
└──────────┴──────────┴──────────┴──────────┴──────────────────────┘
```

### Generated x86-64 Stencil

```asm
; LOAD.D stencil with bounds checking
; RDI = pointer to register file
; Placeholder values: 0x22222222 = src, 0x11111111 = dst

stencil_load_d:
    ; Load the fat pointer from source register
    movabs  rax, 0x2222222222222222     ; Placeholder: source register index
    mov     rax, [rdi + rax*8]          ; Load fat pointer

    ; Extract base address (lower 32 bits)
    mov     rbx, rax
    and     ebx, 0xFFFFFFFF             ; base = fat_ptr & 0xFFFFFFFF

    ; Extract length (bits 32-47)
    mov     rcx, rax
    shr     rcx, 32
    and     ecx, 0xFFFF                 ; length = (fat_ptr >> 32) & 0xFFFF

    ; Bounds check: need at least 8 bytes for LOAD.D
    cmp     ecx, 8
    jb      .trap_out_of_bounds         ; Jump if length < 8

    ; Extract permissions and check read permission (bit 48-55)
    mov     rdx, rax
    shr     rdx, 48
    and     edx, 0xFF
    test    edx, 0x01                   ; Check read permission bit
    jz      .trap_no_permission

    ; All checks passed - perform the actual load
    mov     rax, [rbx]                  ; Load 64-bit value from base

    ; Store to destination register
    movabs  rcx, 0x1111111111111111     ; Placeholder: dest register index
    mov     [rdi + rcx*8], rax          ; Store result

    ret                                  ; Return to compiled code

.trap_out_of_bounds:
    ; Trap handler - will be patched to call runtime
    mov     edi, 1                      ; Error code: OUT_OF_BOUNDS
    jmp     neurlang_trap

.trap_no_permission:
    mov     edi, 2                      ; Error code: NO_PERMISSION
    jmp     neurlang_trap
```

### Patched Output (after compilation)

For instruction `LOAD.D r5, [r3]`:

```asm
; Source register r3 = index 3, Destination register r5 = index 5

    movabs  rax, 3                      ; r3
    mov     rax, [rdi + rax*8]          ; Load fat pointer from r3

    mov     rbx, rax
    and     ebx, 0xFFFFFFFF             ; Extract base

    mov     rcx, rax
    shr     rcx, 32
    and     ecx, 0xFFFF                 ; Extract length

    cmp     ecx, 8
    jb      .trap_out_of_bounds

    mov     rdx, rax
    shr     rdx, 48
    and     edx, 0xFF
    test    edx, 0x01
    jz      .trap_no_permission

    mov     rax, [rbx]                  ; Actual load

    movabs  rcx, 5                      ; r5
    mov     [rdi + rcx*8], rax          ; Store to r5

    ret
```

### Performance Characteristics

| Check | Overhead |
|-------|----------|
| Bounds check | ~3-4 cycles (branch predicted) |
| Permission check | ~2-3 cycles |
| Total overhead | ~6-8 cycles |
| Trap path | ~50+ cycles (rare) |

**The AI writes one instruction. The compiler generates safe native code with implicit security.**

---

## Example: ATOMIC Stencil

Atomic operations are fully inlined using x86's `lock` prefix:

### Neurlang Instruction

```
ATOMIC.CAS r1, [r2], r3, r4    ; Compare-and-swap
; If [r2] == r3, then [r2] = r4, r1 = 1
; Else r1 = 0
```

### Generated x86-64

```asm
stencil_atomic_cas:
    ; Load address from r2
    movabs  rax, 0x2222222222222222
    mov     rax, [rdi + rax*8]
    and     eax, 0xFFFFFFFF             ; Extract base address

    ; Load expected value from r3
    movabs  rbx, 0x3333333333333333
    mov     rbx, [rdi + rbx*8]

    ; Load new value from r4
    movabs  rcx, 0x4444444444444444
    mov     rcx, [rdi + rcx*8]

    ; Perform atomic compare-and-swap
    mov     rdx, rbx                     ; Expected value in RAX for CMPXCHG
    lock cmpxchg [rax], rcx             ; Atomic CAS

    ; Store success flag to r1
    sete    al                           ; AL = 1 if successful
    movzx   rax, al
    movabs  rcx, 0x1111111111111111
    mov     [rdi + rcx*8], rax

    ret
```

**Single `lock cmpxchg` instruction provides hardware atomicity.**

---

## Stencil Size Summary

| Category | Typical Size | Notes |
|----------|--------------|-------|
| ALU operations | 30-45 bytes | Simple register arithmetic |
| Memory with bounds | 60-80 bytes | Includes safety checks |
| Branches | 15-30 bytes | Jump instructions |
| Atomics | 35-50 bytes | lock-prefixed operations |
| Runtime calls | 25-35 bytes | Setup + call + return handling |

**Total stencil table: ~30KB for all 32 opcodes × 8 modes**

---

## See Also

- [How It Works](../architecture/how-it-works.md)
- [Compilation Process](../compiler/README.md)
- [Fat Pointers](../ir/fat-pointers.md)
- [Security Model](../security/README.md)
