//! Go Code Generator for Neurlang IR
//!
//! Translates Neurlang IR to Go code. Go's goroutines and channels
//! map naturally to Neurlang's concurrency primitives.
//!
//! # Features
//!
//! - Goroutines for spawn/join with sync.WaitGroup
//! - Real Go channels for chan operations
//! - sync/atomic for atomic operations including CAS loops for min/max
//! - Memory-safe bounds checking
//! - Complete file I/O operations
//! - Network socket operations via net package
//! - Proper error handling and trap support

use super::common::{
    analyze_branch_targets, format_number, register_name, CodeGenContext, CodeGenOptions,
    IndentWriter,
};
use super::{CodeGenError, CodeGenResult, CodeGenerator};
use crate::ir::{
    AluOp, AtomicOp, BitsOp, BranchCond, ChanOp, FenceMode, FileOp, FpuOp, Instruction, IoOp,
    MemWidth, MulDivOp, NetOp, Opcode, Program, RandOp, Register, TimeOp, TrapType,
};

/// Go code generator
pub struct GoCodeGenerator {
    writer: IndentWriter,
    context: CodeGenContext,
    options: CodeGenOptions,
}

impl GoCodeGenerator {
    /// Create a new Go code generator
    pub fn new() -> Self {
        Self {
            writer: IndentWriter::new(),
            context: CodeGenContext::new(0),
            options: CodeGenOptions::default(),
        }
    }

    /// Create with custom options
    pub fn with_options(options: CodeGenOptions) -> Self {
        Self {
            writer: IndentWriter::with_options(options.clone()),
            context: CodeGenContext::new(0),
            options,
        }
    }

    /// Get the ALU operation as a Go operator
    fn alu_op_str(op: AluOp) -> &'static str {
        match op {
            AluOp::Add => "+",
            AluOp::Sub => "-",
            AluOp::And => "&",
            AluOp::Or => "|",
            AluOp::Xor => "^",
            AluOp::Shl => "<<",
            AluOp::Shr => ">>",
            AluOp::Sar => ">>", // Go's >> is arithmetic for signed types
        }
    }

    /// Get the branch condition as a Go operator
    fn branch_cond_str(cond: BranchCond) -> &'static str {
        match cond {
            BranchCond::Always => "true",
            BranchCond::Eq => "==",
            BranchCond::Ne => "!=",
            BranchCond::Lt => "<",
            BranchCond::Le => "<=",
            BranchCond::Gt => ">",
            BranchCond::Ge => ">=",
            BranchCond::Ltu => "<", // Cast to unsigned needed
        }
    }

    /// Write a register access
    fn reg(&self, r: Register) -> String {
        if r == Register::Zero {
            "0".to_string()
        } else {
            format!("regs[{}]", r as usize)
        }
    }

    /// Write a register assignment (returns None if not writable)
    fn reg_assign(&self, r: Register) -> Option<String> {
        if r == Register::Zero || r == Register::Pc {
            None
        } else {
            Some(format!("regs[{}]", r as usize))
        }
    }
}

impl Default for GoCodeGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl CodeGenerator for GoCodeGenerator {
    fn target_name(&self) -> &'static str {
        "Go"
    }

    fn file_extension(&self) -> &'static str {
        "go"
    }

    fn generate(&mut self, program: &Program) -> CodeGenResult<String> {
        self.context = CodeGenContext::new(program.instructions.len());
        self.context.branch_targets = analyze_branch_targets(program);
        self.writer = IndentWriter::with_options(self.options.clone());

        self.emit_prologue()?;

        // Emit all instructions
        for (index, instr) in program.instructions.iter().enumerate() {
            self.context.current_index = index;
            self.emit_instruction(instr, index)?;
        }

        self.emit_epilogue()?;

        Ok(self.writer.output().to_string())
    }

    fn emit_prologue(&mut self) -> CodeGenResult<()> {
        self.writer
            .writeln("// Generated by Neurlang Go Code Generator");
        self.writer.writeln("package main");
        self.writer.newline();
        self.writer.writeln("import (");
        self.writer.indent();
        self.writer.writeln("\"encoding/binary\"");
        self.writer.writeln("\"fmt\"");
        self.writer.writeln("\"math\"");
        self.writer.writeln("\"math/bits\"");
        self.writer.writeln("\"math/rand\"");
        self.writer.writeln("\"net\"");
        self.writer.writeln("\"os\"");
        self.writer.writeln("\"sync\"");
        self.writer.writeln("\"sync/atomic\"");
        self.writer.writeln("\"syscall\"");
        self.writer.writeln("\"time\"");
        self.writer.writeln("\"unsafe\"");
        self.writer.dedent();
        self.writer.writeln(")");
        self.writer.newline();

        // Suppress unused import warnings
        self.writer.writeln("var (");
        self.writer.indent();
        self.writer.writeln("_ = binary.LittleEndian");
        self.writer.writeln("_ = fmt.Println");
        self.writer.writeln("_ = math.Sqrt");
        self.writer.writeln("_ = bits.OnesCount64");
        self.writer.writeln("_ = rand.Int63");
        self.writer.writeln("_ = net.Dial");
        self.writer.writeln("_ = os.Exit");
        self.writer.writeln("_ = sync.WaitGroup{}");
        self.writer.writeln("_ = atomic.AddUint64");
        self.writer.writeln("_ = syscall.O_RDONLY");
        self.writer.writeln("_ = time.Now");
        self.writer.writeln("_ = unsafe.Pointer(nil)");
        self.writer.dedent();
        self.writer.writeln(")");
        self.writer.newline();

        // Register and memory definitions
        self.writer
            .writeln("// Register file: r0-r15, sp, fp, lr, pc, csp, cfp, reserved, zero");
        self.writer.writeln("var regs [32]uint64");
        self.writer.writeln("var memory []byte");
        self.writer.newline();

        // Concurrency primitives
        self.writer.writeln("// Concurrency management");
        self.writer.writeln("var (");
        self.writer.indent();
        self.writer.writeln("taskWg sync.WaitGroup");
        self.writer.writeln("taskMu sync.Mutex");
        self.writer.writeln("taskID uint64");
        self.writer
            .writeln("taskDone = make(map[uint64]chan struct{})");
        self.writer.dedent();
        self.writer.writeln(")");
        self.writer.newline();

        // Channel management
        self.writer.writeln("// Channel management");
        self.writer.writeln("var (");
        self.writer.indent();
        self.writer.writeln("chanMu sync.Mutex");
        self.writer.writeln("chanID uint64");
        self.writer
            .writeln("channels = make(map[uint64]chan uint64)");
        self.writer.dedent();
        self.writer.writeln(")");
        self.writer.newline();

        // File handle management
        self.writer.writeln("// File handle management");
        self.writer.writeln("var (");
        self.writer.indent();
        self.writer.writeln("fileMu sync.Mutex");
        self.writer
            .writeln("fileID uint64 = 3 // Start after stdin/stdout/stderr");
        self.writer.writeln("files = make(map[uint64]*os.File)");
        self.writer.dedent();
        self.writer.writeln(")");
        self.writer.newline();

        // Network connection management
        self.writer.writeln("// Network connection management");
        self.writer.writeln("var (");
        self.writer.indent();
        self.writer.writeln("connMu sync.Mutex");
        self.writer.writeln("connID uint64");
        self.writer.writeln("conns = make(map[uint64]net.Conn)");
        self.writer
            .writeln("listeners = make(map[uint64]net.Listener)");
        self.writer.dedent();
        self.writer.writeln(")");
        self.writer.newline();

        // Memory access helpers
        self.writer.writeln("// Safe memory access functions");
        self.writer.writeln("func load8(addr uint64) uint64 {");
        self.writer.indent();
        self.writer.writeln("if addr < uint64(len(memory)) {");
        self.writer.indent();
        self.writer.writeln("return uint64(memory[addr])");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.writeln("return 0");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        self.writer.writeln("func load16(addr uint64) uint64 {");
        self.writer.indent();
        self.writer.writeln("if addr+1 < uint64(len(memory)) {");
        self.writer.indent();
        self.writer
            .writeln("return uint64(binary.LittleEndian.Uint16(memory[addr:]))");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.writeln("return 0");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        self.writer.writeln("func load32(addr uint64) uint64 {");
        self.writer.indent();
        self.writer.writeln("if addr+3 < uint64(len(memory)) {");
        self.writer.indent();
        self.writer
            .writeln("return uint64(binary.LittleEndian.Uint32(memory[addr:]))");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.writeln("return 0");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        self.writer.writeln("func load64(addr uint64) uint64 {");
        self.writer.indent();
        self.writer.writeln("if addr+7 < uint64(len(memory)) {");
        self.writer.indent();
        self.writer
            .writeln("return binary.LittleEndian.Uint64(memory[addr:])");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.writeln("return 0");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        self.writer
            .writeln("func store8(addr uint64, val uint64) {");
        self.writer.indent();
        self.writer.writeln("if addr < uint64(len(memory)) {");
        self.writer.indent();
        self.writer.writeln("memory[addr] = byte(val)");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        self.writer
            .writeln("func store16(addr uint64, val uint64) {");
        self.writer.indent();
        self.writer.writeln("if addr+1 < uint64(len(memory)) {");
        self.writer.indent();
        self.writer
            .writeln("binary.LittleEndian.PutUint16(memory[addr:], uint16(val))");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        self.writer
            .writeln("func store32(addr uint64, val uint64) {");
        self.writer.indent();
        self.writer.writeln("if addr+3 < uint64(len(memory)) {");
        self.writer.indent();
        self.writer
            .writeln("binary.LittleEndian.PutUint32(memory[addr:], uint32(val))");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        self.writer
            .writeln("func store64(addr uint64, val uint64) {");
        self.writer.indent();
        self.writer.writeln("if addr+7 < uint64(len(memory)) {");
        self.writer.indent();
        self.writer
            .writeln("binary.LittleEndian.PutUint64(memory[addr:], val)");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        // Atomic min/max helpers using CAS loop
        self.writer
            .writeln("// Atomic min using compare-and-swap loop");
        self.writer
            .writeln("func atomicMin(addr *uint64, val uint64) uint64 {");
        self.writer.indent();
        self.writer.writeln("for {");
        self.writer.indent();
        self.writer.writeln("old := atomic.LoadUint64(addr)");
        self.writer.writeln("if val >= old {");
        self.writer.indent();
        self.writer.writeln("return old");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer
            .writeln("if atomic.CompareAndSwapUint64(addr, old, val) {");
        self.writer.indent();
        self.writer.writeln("return old");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        self.writer
            .writeln("// Atomic max using compare-and-swap loop");
        self.writer
            .writeln("func atomicMax(addr *uint64, val uint64) uint64 {");
        self.writer.indent();
        self.writer.writeln("for {");
        self.writer.indent();
        self.writer.writeln("old := atomic.LoadUint64(addr)");
        self.writer.writeln("if val <= old {");
        self.writer.indent();
        self.writer.writeln("return old");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer
            .writeln("if atomic.CompareAndSwapUint64(addr, old, val) {");
        self.writer.indent();
        self.writer.writeln("return old");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        // Helper to read null-terminated string from memory
        self.writer
            .writeln("// Read null-terminated string from memory");
        self.writer.writeln("func readString(addr uint64) string {");
        self.writer.indent();
        self.writer.writeln("var result []byte");
        self.writer
            .writeln("for i := addr; i < uint64(len(memory)); i++ {");
        self.writer.indent();
        self.writer.writeln("if memory[i] == 0 {");
        self.writer.indent();
        self.writer.writeln("break");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.writeln("result = append(result, memory[i])");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.writeln("return string(result)");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        // Execution function
        self.writer.writeln("func execute() {");
        self.writer.indent();

        Ok(())
    }

    fn emit_epilogue(&mut self) -> CodeGenResult<()> {
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        // Main function
        self.writer.writeln("func main() {");
        self.writer.indent();
        self.writer.writeln("// Initialize memory (1MB)");
        self.writer.writeln("memory = make([]byte, 1024*1024)");
        self.writer.newline();
        self.writer.writeln("// Initialize stack pointer");
        self.writer
            .writeln("regs[16] = uint64(len(memory) - 8) // sp");
        self.writer.newline();
        self.writer.writeln("// Execute program");
        self.writer.writeln("execute()");
        self.writer.newline();
        self.writer.writeln("// Exit with r0 as code");
        self.writer.writeln("os.Exit(int(regs[0]))");
        self.writer.dedent();
        self.writer.writeln("}");

        Ok(())
    }

    fn emit_instruction(&mut self, instr: &Instruction, index: usize) -> CodeGenResult<()> {
        // Emit label if this is a branch target
        if self.context.is_branch_target(index) {
            self.writer.dedent();
            self.writer.writeln(&format!("L{}:", index));
            self.writer.indent();
        }

        match instr.opcode {
            Opcode::Alu => {
                let op = AluOp::from_u8(instr.mode).unwrap_or(AluOp::Add);
                self.emit_alu(op, instr.rd, instr.rs1, instr.rs2)?;
            }
            Opcode::AluI => {
                let op = AluOp::from_u8(instr.mode).unwrap_or(AluOp::Add);
                let imm = instr.imm.ok_or(CodeGenError::MissingImmediate(index))?;
                self.emit_alu_imm(op, instr.rd, instr.rs1, imm)?;
            }
            Opcode::MulDiv => {
                let op = MulDivOp::from_u8(instr.mode).unwrap_or(MulDivOp::Mul);
                self.emit_muldiv(op, instr.rd, instr.rs1, instr.rs2)?;
            }
            Opcode::Load => {
                let width = MemWidth::from_u8(instr.mode).unwrap_or(MemWidth::Double);
                let offset = instr.imm.unwrap_or(0);
                self.emit_load(width, instr.rd, instr.rs1, offset)?;
            }
            Opcode::Store => {
                let width = MemWidth::from_u8(instr.mode).unwrap_or(MemWidth::Double);
                let offset = instr.imm.unwrap_or(0);
                self.emit_store(width, instr.rd, instr.rs1, offset)?;
            }
            Opcode::Atomic => {
                let op = AtomicOp::from_u8(instr.mode).unwrap_or(AtomicOp::Cas);
                self.emit_atomic(op, instr.rd, instr.rs1, instr.rs2)?;
            }
            Opcode::Branch => {
                let cond = BranchCond::from_u8(instr.mode).unwrap_or(BranchCond::Always);
                let target = instr.imm.unwrap_or(0);
                self.emit_branch(cond, instr.rs1, instr.rs2, target)?;
            }
            Opcode::Call => {
                let target = instr.imm.unwrap_or(0);
                self.emit_call(target)?;
            }
            Opcode::Ret => self.emit_ret()?,
            Opcode::Jump => {
                let target = instr.imm.unwrap_or(0);
                self.emit_jump(target, instr.mode == 1)?;
            }
            Opcode::CapNew => self.emit_cap_new(instr.rd, instr.rs1, instr.rs2)?,
            Opcode::CapRestrict => self.emit_cap_restrict(instr.rd, instr.rs1, instr.rs2)?,
            Opcode::CapQuery => {
                let query = instr.imm.unwrap_or(0);
                self.emit_cap_query(instr.rd, instr.rs1, query)?;
            }
            Opcode::Spawn => {
                let target = instr.imm.unwrap_or(0);
                self.emit_spawn(instr.rd, target, instr.rs1)?;
            }
            Opcode::Join => self.emit_join(instr.rs1)?,
            Opcode::Chan => {
                let op = ChanOp::from_u8(instr.mode).unwrap_or(ChanOp::Create);
                self.emit_chan(op, instr.rd, instr.rs1)?;
            }
            Opcode::Fence => {
                let mode = FenceMode::from_u8(instr.mode).unwrap_or(FenceMode::SeqCst);
                self.emit_fence(mode)?;
            }
            Opcode::Yield => self.emit_yield()?,
            Opcode::Taint => self.emit_taint(instr.rd, instr.rs1)?,
            Opcode::Sanitize => self.emit_sanitize(instr.rd, instr.rs1)?,
            Opcode::File => {
                let op = FileOp::from_u8(instr.mode).unwrap_or(FileOp::Open);
                self.emit_file(op, instr.rd, instr.rs1, instr.rs2, instr.imm)?;
            }
            Opcode::Net => {
                let op = NetOp::from_u8(instr.mode).unwrap_or(NetOp::Socket);
                self.emit_net(op, instr.rd, instr.rs1, instr.rs2, instr.imm)?;
            }
            Opcode::NetSetopt => {
                self.writer.writeln(&format!(
                    "// net.setopt {} = {}",
                    self.reg(instr.rs1),
                    instr.imm.unwrap_or(0)
                ));
            }
            Opcode::Io => {
                let op = IoOp::from_u8(instr.mode).unwrap_or(IoOp::Print);
                self.emit_io(op, instr.rd, instr.rs1, instr.rs2)?;
            }
            Opcode::Time => {
                let op = TimeOp::from_u8(instr.mode).unwrap_or(TimeOp::Now);
                self.emit_time(op, instr.rd, instr.imm)?;
            }
            Opcode::Fpu => {
                let op = FpuOp::from_u8(instr.mode).unwrap_or(FpuOp::Fadd);
                self.emit_fpu(op, instr.rd, instr.rs1, instr.rs2)?;
            }
            Opcode::Rand => {
                let op = RandOp::from_u8(instr.mode).unwrap_or(RandOp::RandU64);
                self.emit_rand(op, instr.rd, instr.rs1)?;
            }
            Opcode::Bits => {
                let op = BitsOp::from_u8(instr.mode).unwrap_or(BitsOp::Popcount);
                self.emit_bits(op, instr.rd, instr.rs1)?;
            }
            Opcode::Mov => self.emit_mov(instr.rd, instr.rs1, instr.imm)?,
            Opcode::Trap => {
                let trap = TrapType::from_u8(instr.mode).unwrap_or(TrapType::User);
                self.emit_trap(trap, instr.imm)?;
            }
            Opcode::Nop => self.emit_nop()?,
            Opcode::Halt => self.emit_halt()?,
            Opcode::ExtCall => {
                let ext_id = instr.imm.unwrap_or(0);
                self.emit_ext_call(instr.rd, ext_id, instr.rs1, instr.rs2)?;
            }
        }

        Ok(())
    }

    fn emit_alu(
        &mut self,
        op: AluOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            let op_str = Self::alu_op_str(op);
            if op == AluOp::Sar {
                // Arithmetic right shift
                self.writer.writeln(&format!(
                    "{} = uint64(int64({}) {} {})",
                    dst,
                    self.reg(rs1),
                    op_str,
                    self.reg(rs2)
                ));
            } else {
                self.writer.writeln(&format!(
                    "{} = {} {} {}",
                    dst,
                    self.reg(rs1),
                    op_str,
                    self.reg(rs2)
                ));
            }
        }
        Ok(())
    }

    fn emit_alu_imm(
        &mut self,
        op: AluOp,
        rd: Register,
        rs1: Register,
        imm: i32,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            let op_str = Self::alu_op_str(op);
            if op == AluOp::Sar {
                self.writer.writeln(&format!(
                    "{} = uint64(int64({}) {} {})",
                    dst,
                    self.reg(rs1),
                    op_str,
                    imm
                ));
            } else {
                self.writer.writeln(&format!(
                    "{} = {} {} {}",
                    dst,
                    self.reg(rs1),
                    op_str,
                    format_number(imm)
                ));
            }
        }
        Ok(())
    }

    fn emit_muldiv(
        &mut self,
        op: MulDivOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            match op {
                MulDivOp::Mul => {
                    self.writer.writeln(&format!(
                        "{} = {} * {}",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                MulDivOp::MulH => {
                    self.writer.writeln(&format!(
                        "{} = bits.Mul64({}, {}).Hi",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                MulDivOp::Div => {
                    self.writer.writeln(&format!(
                        "if {} != 0 {{ {} = {} / {} }} else {{ {} = 0 }}",
                        self.reg(rs2),
                        dst,
                        self.reg(rs1),
                        self.reg(rs2),
                        dst
                    ));
                }
                MulDivOp::Mod => {
                    self.writer.writeln(&format!(
                        "if {} != 0 {{ {} = {} % {} }} else {{ {} = 0 }}",
                        self.reg(rs2),
                        dst,
                        self.reg(rs1),
                        self.reg(rs2),
                        dst
                    ));
                }
            }
        }
        Ok(())
    }

    fn emit_load(
        &mut self,
        width: MemWidth,
        rd: Register,
        base: Register,
        offset: i32,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            let func = match width {
                MemWidth::Byte => "load8",
                MemWidth::Half => "load16",
                MemWidth::Word => "load32",
                MemWidth::Double => "load64",
            };
            if offset != 0 {
                self.writer.writeln(&format!(
                    "{} = {}({} + {})",
                    dst,
                    func,
                    self.reg(base),
                    format_number(offset)
                ));
            } else {
                self.writer
                    .writeln(&format!("{} = {}({})", dst, func, self.reg(base)));
            }
        }
        Ok(())
    }

    fn emit_store(
        &mut self,
        width: MemWidth,
        src: Register,
        base: Register,
        offset: i32,
    ) -> CodeGenResult<()> {
        let func = match width {
            MemWidth::Byte => "store8",
            MemWidth::Half => "store16",
            MemWidth::Word => "store32",
            MemWidth::Double => "store64",
        };
        if offset != 0 {
            self.writer.writeln(&format!(
                "{}({} + {}, {})",
                func,
                self.reg(base),
                format_number(offset),
                self.reg(src)
            ));
        } else {
            self.writer
                .writeln(&format!("{}({}, {})", func, self.reg(base), self.reg(src)));
        }
        Ok(())
    }

    fn emit_atomic(
        &mut self,
        op: AtomicOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            let addr_expr = format!("(*uint64)(unsafe.Pointer(&memory[{}]))", self.reg(rs1));
            match op {
                AtomicOp::Add => {
                    // Atomic add: returns old value, stores old + val
                    self.writer.writeln(&format!(
                        "{} = atomic.AddUint64({}, {}) - {} // atomic.add returns new value, adjust to old",
                        dst, addr_expr, self.reg(rs2), self.reg(rs2)
                    ));
                }
                AtomicOp::And => {
                    // Atomic and using CAS loop
                    self.writer.writeln("{");
                    self.writer.indent();
                    self.writer.writeln(&format!("addr := {}", addr_expr));
                    self.writer.writeln(&format!("val := {}", self.reg(rs2)));
                    self.writer.writeln("for {");
                    self.writer.indent();
                    self.writer.writeln("old := atomic.LoadUint64(addr)");
                    self.writer
                        .writeln("if atomic.CompareAndSwapUint64(addr, old, old & val) {");
                    self.writer.indent();
                    self.writer.writeln(&format!("{} = old", dst));
                    self.writer.writeln("break");
                    self.writer.dedent();
                    self.writer.writeln("}");
                    self.writer.dedent();
                    self.writer.writeln("}");
                    self.writer.dedent();
                    self.writer.writeln("}");
                }
                AtomicOp::Or => {
                    // Atomic or using CAS loop
                    self.writer.writeln("{");
                    self.writer.indent();
                    self.writer.writeln(&format!("addr := {}", addr_expr));
                    self.writer.writeln(&format!("val := {}", self.reg(rs2)));
                    self.writer.writeln("for {");
                    self.writer.indent();
                    self.writer.writeln("old := atomic.LoadUint64(addr)");
                    self.writer
                        .writeln("if atomic.CompareAndSwapUint64(addr, old, old | val) {");
                    self.writer.indent();
                    self.writer.writeln(&format!("{} = old", dst));
                    self.writer.writeln("break");
                    self.writer.dedent();
                    self.writer.writeln("}");
                    self.writer.dedent();
                    self.writer.writeln("}");
                    self.writer.dedent();
                    self.writer.writeln("}");
                }
                AtomicOp::Xor => {
                    // Atomic xor using CAS loop
                    self.writer.writeln("{");
                    self.writer.indent();
                    self.writer.writeln(&format!("addr := {}", addr_expr));
                    self.writer.writeln(&format!("val := {}", self.reg(rs2)));
                    self.writer.writeln("for {");
                    self.writer.indent();
                    self.writer.writeln("old := atomic.LoadUint64(addr)");
                    self.writer
                        .writeln("if atomic.CompareAndSwapUint64(addr, old, old ^ val) {");
                    self.writer.indent();
                    self.writer.writeln(&format!("{} = old", dst));
                    self.writer.writeln("break");
                    self.writer.dedent();
                    self.writer.writeln("}");
                    self.writer.dedent();
                    self.writer.writeln("}");
                    self.writer.dedent();
                    self.writer.writeln("}");
                }
                AtomicOp::Min => {
                    // Atomic min using helper function
                    self.writer.writeln(&format!(
                        "{} = atomicMin({}, {})",
                        dst,
                        addr_expr,
                        self.reg(rs2)
                    ));
                }
                AtomicOp::Max => {
                    // Atomic max using helper function
                    self.writer.writeln(&format!(
                        "{} = atomicMax({}, {})",
                        dst,
                        addr_expr,
                        self.reg(rs2)
                    ));
                }
                AtomicOp::Xchg => {
                    // Atomic exchange: returns old value, stores new value
                    self.writer.writeln(&format!(
                        "{} = atomic.SwapUint64({}, {})",
                        dst,
                        addr_expr,
                        self.reg(rs2)
                    ));
                }
                AtomicOp::Cas => {
                    // Compare-and-swap: compares with expected (rs2), swaps with rd value
                    // Returns 1 on success, 0 on failure
                    self.writer.writeln(&format!(
                        "if atomic.CompareAndSwapUint64({}, {}, {}) {{ {} = 1 }} else {{ {} = 0 }}",
                        addr_expr,
                        self.reg(rs2),
                        dst,
                        dst,
                        dst
                    ));
                }
            }
        }
        Ok(())
    }

    fn emit_branch(
        &mut self,
        cond: BranchCond,
        rs1: Register,
        rs2: Register,
        target: i32,
    ) -> CodeGenResult<()> {
        let target_index = (self.context.current_index as i32 + target) as usize;
        self.context.mark_branch_target(target_index);

        match cond {
            BranchCond::Always => {
                self.writer.writeln(&format!("goto L{}", target_index));
            }
            BranchCond::Ltu => {
                self.writer.writeln(&format!(
                    "if {} < {} {{ goto L{} }}",
                    self.reg(rs1),
                    self.reg(rs2),
                    target_index
                ));
            }
            _ => {
                let op = Self::branch_cond_str(cond);
                self.writer.writeln(&format!(
                    "if int64({}) {} int64({}) {{ goto L{} }}",
                    self.reg(rs1),
                    op,
                    self.reg(rs2),
                    target_index
                ));
            }
        }
        Ok(())
    }

    fn emit_call(&mut self, target: i32) -> CodeGenResult<()> {
        let target_index = (self.context.current_index as i32 + target) as usize;
        self.context.mark_branch_target(target_index);
        self.writer.writeln(&format!(
            "regs[18] = {} // save return address to lr",
            self.context.current_index + 1
        ));
        self.writer.writeln(&format!("goto L{}", target_index));
        Ok(())
    }

    fn emit_ret(&mut self) -> CodeGenResult<()> {
        self.writer.writeln("return // ret");
        Ok(())
    }

    fn emit_jump(&mut self, target: i32, indirect: bool) -> CodeGenResult<()> {
        if indirect {
            self.writer.writeln("// indirect jump not fully supported");
            self.writer.writeln("return");
        } else {
            let target_index = (self.context.current_index as i32 + target) as usize;
            self.context.mark_branch_target(target_index);
            self.writer.writeln(&format!("goto L{}", target_index));
        }
        Ok(())
    }

    fn emit_cap_new(&mut self, rd: Register, base: Register, len: Register) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            self.writer.writeln(&format!(
                "{} = {} // cap.new: base={}, len={}",
                dst,
                self.reg(base),
                self.reg(base),
                self.reg(len)
            ));
        }
        Ok(())
    }

    fn emit_cap_restrict(
        &mut self,
        rd: Register,
        src: Register,
        len: Register,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            self.writer
                .writeln(&format!("{} = {} // cap.restrict", dst, self.reg(src)));
        }
        let _ = len;
        Ok(())
    }

    fn emit_cap_query(
        &mut self,
        rd: Register,
        cap: Register,
        query_type: i32,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            self.writer.writeln(&format!(
                "{} = {} // cap.query type={}",
                dst,
                self.reg(cap),
                query_type
            ));
        }
        Ok(())
    }

    fn emit_spawn(&mut self, rd: Register, target: i32, arg: Register) -> CodeGenResult<()> {
        let target_index = (self.context.current_index as i32 + target) as usize;
        self.context.mark_branch_target(target_index);

        self.writer.writeln("{");
        self.writer.indent();

        // Allocate a unique task ID
        self.writer.writeln("taskMu.Lock()");
        self.writer.writeln("taskID++");
        self.writer.writeln("myTaskID := taskID");
        self.writer.writeln("doneCh := make(chan struct{})");
        self.writer.writeln("taskDone[myTaskID] = doneCh");
        self.writer.writeln("taskMu.Unlock()");
        self.writer.newline();

        // Capture the argument value for the goroutine
        self.writer.writeln(&format!(
            "argVal := {} // capture argument for goroutine",
            self.reg(arg)
        ));
        self.writer
            .writeln("_ = argVal // argument available in spawned task");
        self.writer.newline();

        // Increment WaitGroup and spawn goroutine
        self.writer.writeln("taskWg.Add(1)");
        self.writer
            .writeln("go func(id uint64, done chan struct{}) {");
        self.writer.indent();
        self.writer.writeln("defer taskWg.Done()");
        self.writer.writeln("defer close(done)");
        self.writer
            .writeln(&format!("// Execute task starting at L{}", target_index));
        self.writer
            .writeln("// Note: In a full implementation, this would jump to the target label");
        self.writer
            .writeln("// For now, the spawned code should be inlined or called as a function");
        self.writer.dedent();
        self.writer.writeln("}(myTaskID, doneCh)");
        self.writer.newline();

        if let Some(dst) = self.reg_assign(rd) {
            self.writer
                .writeln(&format!("{} = myTaskID // task ID for join", dst));
        }

        self.writer.dedent();
        self.writer.writeln("}");
        Ok(())
    }

    fn emit_join(&mut self, task: Register) -> CodeGenResult<()> {
        self.writer.writeln("{");
        self.writer.indent();
        self.writer
            .writeln(&format!("taskIDToJoin := {}", self.reg(task)));
        self.writer.writeln("taskMu.Lock()");
        self.writer
            .writeln("doneCh, exists := taskDone[taskIDToJoin]");
        self.writer.writeln("taskMu.Unlock()");
        self.writer.writeln("if exists {");
        self.writer.indent();
        self.writer.writeln("<-doneCh // wait for task to complete");
        self.writer.writeln("taskMu.Lock()");
        self.writer.writeln("delete(taskDone, taskIDToJoin)");
        self.writer.writeln("taskMu.Unlock()");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.dedent();
        self.writer.writeln("}");
        Ok(())
    }

    fn emit_chan(&mut self, op: ChanOp, rd: Register, rs1: Register) -> CodeGenResult<()> {
        match op {
            ChanOp::Create => {
                // Create a buffered channel with buffer size from rs1 (0 = unbuffered)
                self.writer.writeln("{");
                self.writer.indent();
                self.writer
                    .writeln(&format!("bufSize := {}", self.reg(rs1)));
                self.writer.writeln("chanMu.Lock()");
                self.writer.writeln("chanID++");
                self.writer.writeln("myChanID := chanID");
                self.writer
                    .writeln("channels[myChanID] = make(chan uint64, bufSize)");
                self.writer.writeln("chanMu.Unlock()");
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!("{} = myChanID", dst));
                }
                self.writer.dedent();
                self.writer.writeln("}");
            }
            ChanOp::Send => {
                // Send value (rs1) to channel (rd)
                self.writer.writeln("{");
                self.writer.indent();
                self.writer.writeln(&format!("chID := {}", self.reg(rd)));
                self.writer.writeln(&format!("val := {}", self.reg(rs1)));
                self.writer.writeln("chanMu.Lock()");
                self.writer.writeln("ch, exists := channels[chID]");
                self.writer.writeln("chanMu.Unlock()");
                self.writer.writeln("if exists {");
                self.writer.indent();
                self.writer.writeln("ch <- val");
                self.writer.dedent();
                self.writer.writeln("}");
                self.writer.dedent();
                self.writer.writeln("}");
            }
            ChanOp::Recv => {
                // Receive from channel (rs1) into rd
                self.writer.writeln("{");
                self.writer.indent();
                self.writer.writeln(&format!("chID := {}", self.reg(rs1)));
                self.writer.writeln("chanMu.Lock()");
                self.writer.writeln("ch, exists := channels[chID]");
                self.writer.writeln("chanMu.Unlock()");
                self.writer.writeln("var val uint64");
                self.writer.writeln("if exists {");
                self.writer.indent();
                self.writer.writeln("val = <-ch");
                self.writer.dedent();
                self.writer.writeln("}");
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!("{} = val", dst));
                }
                self.writer.dedent();
                self.writer.writeln("}");
            }
            ChanOp::Close => {
                // Close channel (rd)
                self.writer.writeln("{");
                self.writer.indent();
                self.writer.writeln(&format!("chID := {}", self.reg(rd)));
                self.writer.writeln("chanMu.Lock()");
                self.writer
                    .writeln("if ch, exists := channels[chID]; exists {");
                self.writer.indent();
                self.writer.writeln("close(ch)");
                self.writer.writeln("delete(channels, chID)");
                self.writer.dedent();
                self.writer.writeln("}");
                self.writer.writeln("chanMu.Unlock()");
                self.writer.dedent();
                self.writer.writeln("}");
            }
        }
        Ok(())
    }

    fn emit_fence(&mut self, mode: FenceMode) -> CodeGenResult<()> {
        self.writer.writeln(&format!(
            "atomic.CompareAndSwapUint64(&regs[0], regs[0], regs[0]) // fence {:?}",
            mode
        ));
        Ok(())
    }

    fn emit_yield(&mut self) -> CodeGenResult<()> {
        self.writer.writeln("time.Sleep(0) // yield");
        Ok(())
    }

    fn emit_taint(&mut self, rd: Register, rs1: Register) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            self.writer
                .writeln(&format!("{} = {} // taint", dst, self.reg(rs1)));
        }
        Ok(())
    }

    fn emit_sanitize(&mut self, rd: Register, rs1: Register) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            self.writer
                .writeln(&format!("{} = {} // sanitize", dst, self.reg(rs1)));
        }
        Ok(())
    }

    fn emit_file(
        &mut self,
        op: FileOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
        imm: Option<i32>,
    ) -> CodeGenResult<()> {
        match op {
            FileOp::Open => {
                // Open file: rs1 = path address, imm = flags
                // Returns file descriptor in rd
                self.writer.writeln("{");
                self.writer.indent();
                self.writer
                    .writeln(&format!("path := readString({})", self.reg(rs1)));
                let flags = imm.unwrap_or(0);
                self.writer.writeln(&format!(
                    "flags := {} // O_RDONLY=0, O_WRONLY=1, O_RDWR=2, O_CREATE=64, O_TRUNC=512",
                    flags
                ));
                self.writer.writeln("var goFlags int");
                self.writer
                    .writeln("if flags & 2 != 0 { goFlags = os.O_RDWR }");
                self.writer
                    .writeln("else if flags & 1 != 0 { goFlags = os.O_WRONLY }");
                self.writer.writeln("else { goFlags = os.O_RDONLY }");
                self.writer
                    .writeln("if flags & 64 != 0 { goFlags |= os.O_CREATE }");
                self.writer
                    .writeln("if flags & 512 != 0 { goFlags |= os.O_TRUNC }");
                self.writer
                    .writeln("if flags & 1024 != 0 { goFlags |= os.O_APPEND }");
                self.writer
                    .writeln("f, err := os.OpenFile(path, goFlags, 0644)");
                self.writer.writeln("var fd uint64");
                self.writer.writeln("if err == nil {");
                self.writer.indent();
                self.writer.writeln("fileMu.Lock()");
                self.writer.writeln("fileID++");
                self.writer.writeln("fd = fileID");
                self.writer.writeln("files[fd] = f");
                self.writer.writeln("fileMu.Unlock()");
                self.writer.dedent();
                self.writer.writeln("} else {");
                self.writer.indent();
                self.writer
                    .writeln("fd = 0xFFFFFFFFFFFFFFFF // -1 on error");
                self.writer.dedent();
                self.writer.writeln("}");
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!("{} = fd", dst));
                }
                self.writer.dedent();
                self.writer.writeln("}");
            }
            FileOp::Close => {
                // Close file: rd = file descriptor
                self.writer.writeln("{");
                self.writer.indent();
                self.writer.writeln(&format!("fd := {}", self.reg(rd)));
                self.writer.writeln("fileMu.Lock()");
                self.writer.writeln("if f, exists := files[fd]; exists {");
                self.writer.indent();
                self.writer.writeln("f.Close()");
                self.writer.writeln("delete(files, fd)");
                self.writer.dedent();
                self.writer.writeln("}");
                self.writer.writeln("fileMu.Unlock()");
                self.writer.dedent();
                self.writer.writeln("}");
            }
            FileOp::Read => {
                // Read from file: rd = fd, rs1 = buffer addr, rs2 = count
                // Returns bytes read in rd
                self.writer.writeln("{");
                self.writer.indent();
                self.writer.writeln(&format!("fd := {}", self.reg(rd)));
                self.writer
                    .writeln(&format!("bufAddr := {}", self.reg(rs1)));
                self.writer.writeln(&format!("count := {}", self.reg(rs2)));
                self.writer.writeln("var bytesRead uint64");
                self.writer.writeln("fileMu.Lock()");
                self.writer.writeln("f, exists := files[fd]");
                self.writer.writeln("fileMu.Unlock()");
                self.writer
                    .writeln("if exists && bufAddr+count <= uint64(len(memory)) {");
                self.writer.indent();
                self.writer
                    .writeln("n, _ := f.Read(memory[bufAddr : bufAddr+count])");
                self.writer.writeln("bytesRead = uint64(n)");
                self.writer.dedent();
                self.writer.writeln("}");
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!("{} = bytesRead", dst));
                }
                self.writer.dedent();
                self.writer.writeln("}");
            }
            FileOp::Write => {
                // Write to file: rd = fd, rs1 = buffer addr, rs2 = count
                // Returns bytes written in rd
                self.writer.writeln("{");
                self.writer.indent();
                self.writer.writeln(&format!("fd := {}", self.reg(rd)));
                self.writer
                    .writeln(&format!("bufAddr := {}", self.reg(rs1)));
                self.writer.writeln(&format!("count := {}", self.reg(rs2)));
                self.writer.writeln("var bytesWritten uint64");
                self.writer.writeln("fileMu.Lock()");
                self.writer.writeln("f, exists := files[fd]");
                self.writer.writeln("fileMu.Unlock()");
                self.writer
                    .writeln("if exists && bufAddr+count <= uint64(len(memory)) {");
                self.writer.indent();
                self.writer
                    .writeln("n, _ := f.Write(memory[bufAddr : bufAddr+count])");
                self.writer.writeln("bytesWritten = uint64(n)");
                self.writer.dedent();
                self.writer.writeln("}");
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!("{} = bytesWritten", dst));
                }
                self.writer.dedent();
                self.writer.writeln("}");
            }
            FileOp::Seek => {
                // Seek in file: rd = fd, rs1 = offset, imm = whence (0=start, 1=current, 2=end)
                // Returns new position in rd
                self.writer.writeln("{");
                self.writer.indent();
                self.writer.writeln(&format!("fd := {}", self.reg(rd)));
                self.writer
                    .writeln(&format!("offset := int64({})", self.reg(rs1)));
                let whence = imm.unwrap_or(0);
                self.writer.writeln(&format!(
                    "whence := {} // 0=SEEK_SET, 1=SEEK_CUR, 2=SEEK_END",
                    whence
                ));
                self.writer.writeln("var newPos uint64");
                self.writer.writeln("fileMu.Lock()");
                self.writer.writeln("f, exists := files[fd]");
                self.writer.writeln("fileMu.Unlock()");
                self.writer.writeln("if exists {");
                self.writer.indent();
                self.writer.writeln("pos, err := f.Seek(offset, whence)");
                self.writer.writeln("if err == nil {");
                self.writer.indent();
                self.writer.writeln("newPos = uint64(pos)");
                self.writer.dedent();
                self.writer.writeln("} else {");
                self.writer.indent();
                self.writer
                    .writeln("newPos = 0xFFFFFFFFFFFFFFFF // -1 on error");
                self.writer.dedent();
                self.writer.writeln("}");
                self.writer.dedent();
                self.writer.writeln("}");
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!("{} = newPos", dst));
                }
                self.writer.dedent();
                self.writer.writeln("}");
            }
            FileOp::Stat => {
                // Stat file: rs1 = path address, rd receives size (or -1 on error)
                self.writer.writeln("{");
                self.writer.indent();
                self.writer
                    .writeln(&format!("path := readString({})", self.reg(rs1)));
                self.writer.writeln("var size uint64");
                self.writer.writeln("info, err := os.Stat(path)");
                self.writer.writeln("if err == nil {");
                self.writer.indent();
                self.writer.writeln("size = uint64(info.Size())");
                self.writer.dedent();
                self.writer.writeln("} else {");
                self.writer.indent();
                self.writer
                    .writeln("size = 0xFFFFFFFFFFFFFFFF // -1 on error");
                self.writer.dedent();
                self.writer.writeln("}");
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!("{} = size", dst));
                }
                self.writer.dedent();
                self.writer.writeln("}");
            }
            FileOp::Mkdir => {
                // Create directory: rs1 = path address
                // Returns 0 on success, -1 on error
                self.writer.writeln("{");
                self.writer.indent();
                self.writer
                    .writeln(&format!("path := readString({})", self.reg(rs1)));
                self.writer.writeln("var result uint64");
                self.writer
                    .writeln("if err := os.MkdirAll(path, 0755); err == nil {");
                self.writer.indent();
                self.writer.writeln("result = 0");
                self.writer.dedent();
                self.writer.writeln("} else {");
                self.writer.indent();
                self.writer
                    .writeln("result = 0xFFFFFFFFFFFFFFFF // -1 on error");
                self.writer.dedent();
                self.writer.writeln("}");
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!("{} = result", dst));
                }
                self.writer.dedent();
                self.writer.writeln("}");
            }
            FileOp::Delete => {
                // Delete file/directory: rs1 = path address
                // Returns 0 on success, -1 on error
                self.writer.writeln("{");
                self.writer.indent();
                self.writer
                    .writeln(&format!("path := readString({})", self.reg(rs1)));
                self.writer.writeln("var result uint64");
                self.writer
                    .writeln("if err := os.Remove(path); err == nil {");
                self.writer.indent();
                self.writer.writeln("result = 0");
                self.writer.dedent();
                self.writer.writeln("} else {");
                self.writer.indent();
                self.writer
                    .writeln("result = 0xFFFFFFFFFFFFFFFF // -1 on error");
                self.writer.dedent();
                self.writer.writeln("}");
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!("{} = result", dst));
                }
                self.writer.dedent();
                self.writer.writeln("}");
            }
        }
        Ok(())
    }

    fn emit_net(
        &mut self,
        op: NetOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
        imm: Option<i32>,
    ) -> CodeGenResult<()> {
        match op {
            NetOp::Socket => {
                // Create socket: imm specifies protocol (0=TCP, 1=UDP)
                // Returns socket ID in rd (stored for later use with connect/bind)
                self.writer.writeln("{");
                self.writer.indent();
                let proto = imm.unwrap_or(0);
                self.writer
                    .writeln(&format!("protocol := {} // 0=TCP, 1=UDP", proto));
                self.writer.writeln("connMu.Lock()");
                self.writer.writeln("connID++");
                self.writer.writeln("sockID := connID");
                self.writer.writeln("connMu.Unlock()");
                self.writer
                    .writeln("_ = protocol // protocol will be used during connect/listen");
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!(
                        "{} = sockID // socket handle for later operations",
                        dst
                    ));
                }
                self.writer.dedent();
                self.writer.writeln("}");
            }
            NetOp::Connect => {
                // Connect: rs1 = address string ptr, rs2 = port
                // Returns 0 on success, -1 on error in rd
                self.writer.writeln("{");
                self.writer.indent();
                self.writer.writeln(&format!("sockID := {}", self.reg(rd)));
                self.writer
                    .writeln(&format!("addr := readString({})", self.reg(rs1)));
                self.writer.writeln(&format!("port := {}", self.reg(rs2)));
                self.writer
                    .writeln("address := fmt.Sprintf(\"%s:%d\", addr, port)");
                self.writer
                    .writeln("conn, err := net.Dial(\"tcp\", address)");
                self.writer.writeln("var result uint64");
                self.writer.writeln("if err == nil {");
                self.writer.indent();
                self.writer.writeln("connMu.Lock()");
                self.writer.writeln("conns[sockID] = conn");
                self.writer.writeln("connMu.Unlock()");
                self.writer.writeln("result = 0");
                self.writer.dedent();
                self.writer.writeln("} else {");
                self.writer.indent();
                self.writer
                    .writeln("result = 0xFFFFFFFFFFFFFFFF // -1 on error");
                self.writer.dedent();
                self.writer.writeln("}");
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!("{} = result", dst));
                }
                self.writer.dedent();
                self.writer.writeln("}");
            }
            NetOp::Bind => {
                // Bind: rs1 = address string ptr (or 0 for any), rs2 = port
                // Prepares for listen, returns 0 on success
                self.writer.writeln("{");
                self.writer.indent();
                self.writer.writeln(&format!("sockID := {}", self.reg(rd)));
                self.writer
                    .writeln(&format!("addrPtr := {}", self.reg(rs1)));
                self.writer.writeln(&format!("port := {}", self.reg(rs2)));
                self.writer.writeln("var addr string");
                self.writer.writeln(
                    "if addrPtr != 0 { addr = readString(addrPtr) } else { addr = \"0.0.0.0\" }",
                );
                self.writer
                    .writeln("address := fmt.Sprintf(\"%s:%d\", addr, port)");
                self.writer
                    .writeln("listener, err := net.Listen(\"tcp\", address)");
                self.writer.writeln("var result uint64");
                self.writer.writeln("if err == nil {");
                self.writer.indent();
                self.writer.writeln("connMu.Lock()");
                self.writer.writeln("listeners[sockID] = listener");
                self.writer.writeln("connMu.Unlock()");
                self.writer.writeln("result = 0");
                self.writer.dedent();
                self.writer.writeln("} else {");
                self.writer.indent();
                self.writer
                    .writeln("result = 0xFFFFFFFFFFFFFFFF // -1 on error");
                self.writer.dedent();
                self.writer.writeln("}");
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!("{} = result", dst));
                }
                self.writer.dedent();
                self.writer.writeln("}");
            }
            NetOp::Listen => {
                // Listen: rd = socket ID, imm = backlog (ignored in Go, handled by OS)
                // In Go, Listen is combined with Bind, so this is a no-op
                self.writer.writeln(&format!(
                    "// net.listen: socket {} already listening (combined with bind in Go)",
                    self.reg(rd)
                ));
            }
            NetOp::Accept => {
                // Accept: rd = listener socket ID
                // Returns new connection socket ID in rd
                self.writer.writeln("{");
                self.writer.indent();
                self.writer
                    .writeln(&format!("listenerID := {}", self.reg(rd)));
                self.writer.writeln("connMu.Lock()");
                self.writer
                    .writeln("listener, exists := listeners[listenerID]");
                self.writer.writeln("connMu.Unlock()");
                self.writer.writeln("var newSockID uint64");
                self.writer.writeln("if exists {");
                self.writer.indent();
                self.writer.writeln("conn, err := listener.Accept()");
                self.writer.writeln("if err == nil {");
                self.writer.indent();
                self.writer.writeln("connMu.Lock()");
                self.writer.writeln("connID++");
                self.writer.writeln("newSockID = connID");
                self.writer.writeln("conns[newSockID] = conn");
                self.writer.writeln("connMu.Unlock()");
                self.writer.dedent();
                self.writer.writeln("} else {");
                self.writer.indent();
                self.writer
                    .writeln("newSockID = 0xFFFFFFFFFFFFFFFF // -1 on error");
                self.writer.dedent();
                self.writer.writeln("}");
                self.writer.dedent();
                self.writer.writeln("} else {");
                self.writer.indent();
                self.writer
                    .writeln("newSockID = 0xFFFFFFFFFFFFFFFF // -1 invalid listener");
                self.writer.dedent();
                self.writer.writeln("}");
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!("{} = newSockID", dst));
                }
                self.writer.dedent();
                self.writer.writeln("}");
            }
            NetOp::Send => {
                // Send: rd = socket ID, rs1 = buffer addr, rs2 = length
                // Returns bytes sent in rd
                self.writer.writeln("{");
                self.writer.indent();
                self.writer.writeln(&format!("sockID := {}", self.reg(rd)));
                self.writer
                    .writeln(&format!("bufAddr := {}", self.reg(rs1)));
                self.writer.writeln(&format!("length := {}", self.reg(rs2)));
                self.writer.writeln("var bytesSent uint64");
                self.writer.writeln("connMu.Lock()");
                self.writer.writeln("conn, exists := conns[sockID]");
                self.writer.writeln("connMu.Unlock()");
                self.writer
                    .writeln("if exists && bufAddr+length <= uint64(len(memory)) {");
                self.writer.indent();
                self.writer
                    .writeln("n, err := conn.Write(memory[bufAddr : bufAddr+length])");
                self.writer.writeln("if err == nil {");
                self.writer.indent();
                self.writer.writeln("bytesSent = uint64(n)");
                self.writer.dedent();
                self.writer.writeln("} else {");
                self.writer.indent();
                self.writer
                    .writeln("bytesSent = 0xFFFFFFFFFFFFFFFF // -1 on error");
                self.writer.dedent();
                self.writer.writeln("}");
                self.writer.dedent();
                self.writer.writeln("} else {");
                self.writer.indent();
                self.writer
                    .writeln("bytesSent = 0xFFFFFFFFFFFFFFFF // -1 invalid socket or buffer");
                self.writer.dedent();
                self.writer.writeln("}");
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!("{} = bytesSent", dst));
                }
                self.writer.dedent();
                self.writer.writeln("}");
            }
            NetOp::Recv => {
                // Recv: rd = socket ID, rs1 = buffer addr, rs2 = max length
                // Returns bytes received in rd
                self.writer.writeln("{");
                self.writer.indent();
                self.writer.writeln(&format!("sockID := {}", self.reg(rd)));
                self.writer
                    .writeln(&format!("bufAddr := {}", self.reg(rs1)));
                self.writer.writeln(&format!("maxLen := {}", self.reg(rs2)));
                self.writer.writeln("var bytesRecv uint64");
                self.writer.writeln("connMu.Lock()");
                self.writer.writeln("conn, exists := conns[sockID]");
                self.writer.writeln("connMu.Unlock()");
                self.writer
                    .writeln("if exists && bufAddr+maxLen <= uint64(len(memory)) {");
                self.writer.indent();
                self.writer
                    .writeln("n, err := conn.Read(memory[bufAddr : bufAddr+maxLen])");
                self.writer.writeln("if err == nil {");
                self.writer.indent();
                self.writer.writeln("bytesRecv = uint64(n)");
                self.writer.dedent();
                self.writer.writeln("} else {");
                self.writer.indent();
                self.writer.writeln("bytesRecv = 0 // 0 on EOF or error");
                self.writer.dedent();
                self.writer.writeln("}");
                self.writer.dedent();
                self.writer.writeln("} else {");
                self.writer.indent();
                self.writer
                    .writeln("bytesRecv = 0xFFFFFFFFFFFFFFFF // -1 invalid socket or buffer");
                self.writer.dedent();
                self.writer.writeln("}");
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!("{} = bytesRecv", dst));
                }
                self.writer.dedent();
                self.writer.writeln("}");
            }
            NetOp::Close => {
                // Close: rd = socket ID
                self.writer.writeln("{");
                self.writer.indent();
                self.writer.writeln(&format!("sockID := {}", self.reg(rd)));
                self.writer.writeln("connMu.Lock()");
                self.writer
                    .writeln("if conn, exists := conns[sockID]; exists {");
                self.writer.indent();
                self.writer.writeln("conn.Close()");
                self.writer.writeln("delete(conns, sockID)");
                self.writer.dedent();
                self.writer.writeln("}");
                self.writer
                    .writeln("if listener, exists := listeners[sockID]; exists {");
                self.writer.indent();
                self.writer.writeln("listener.Close()");
                self.writer.writeln("delete(listeners, sockID)");
                self.writer.dedent();
                self.writer.writeln("}");
                self.writer.writeln("connMu.Unlock()");
                self.writer.dedent();
                self.writer.writeln("}");
            }
        }
        Ok(())
    }

    fn emit_io(
        &mut self,
        op: IoOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
    ) -> CodeGenResult<()> {
        match op {
            IoOp::Print => {
                // Print string from memory: rs1 = address, rs2 = length
                self.writer.writeln(&format!(
                    "fmt.Print(string(memory[{}:{}+{}])) // io.print",
                    self.reg(rs1),
                    self.reg(rs1),
                    self.reg(rs2)
                ));
            }
            IoOp::ReadLine => {
                // Read from stdin: rs1 = buffer address, rs2 = max length
                // Returns bytes read in rd
                self.writer.writeln("{");
                self.writer.indent();
                self.writer
                    .writeln(&format!("bufAddr := {}", self.reg(rs1)));
                self.writer.writeln(&format!("maxLen := {}", self.reg(rs2)));
                self.writer.writeln("var bytesRead uint64");
                self.writer
                    .writeln("if bufAddr+maxLen <= uint64(len(memory)) {");
                self.writer.indent();
                self.writer
                    .writeln("n, _ := os.Stdin.Read(memory[bufAddr : bufAddr+maxLen])");
                self.writer.writeln("bytesRead = uint64(n)");
                self.writer.dedent();
                self.writer.writeln("}");
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!("{} = bytesRead", dst));
                }
                self.writer.dedent();
                self.writer.writeln("}");
            }
            IoOp::GetArgs => {
                // Get command line arguments count: returns argc in rd
                // Arguments stored sequentially starting at rs1 address
                self.writer.writeln("{");
                self.writer.indent();
                self.writer
                    .writeln(&format!("bufAddr := {}", self.reg(rs1)));
                self.writer.writeln("argc := uint64(len(os.Args))");
                self.writer.writeln("offset := bufAddr");
                self.writer.writeln("for _, arg := range os.Args {");
                self.writer.indent();
                self.writer
                    .writeln("if offset+uint64(len(arg))+1 <= uint64(len(memory)) {");
                self.writer.indent();
                self.writer.writeln("copy(memory[offset:], []byte(arg))");
                self.writer
                    .writeln("memory[offset+uint64(len(arg))] = 0 // null terminate");
                self.writer.writeln("offset += uint64(len(arg)) + 1");
                self.writer.dedent();
                self.writer.writeln("}");
                self.writer.dedent();
                self.writer.writeln("}");
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!("{} = argc", dst));
                }
                self.writer.dedent();
                self.writer.writeln("}");
            }
            IoOp::GetEnv => {
                // Get environment variable: rs1 = name address, rd = value address
                // Returns length of value (0 if not found)
                self.writer.writeln("{");
                self.writer.indent();
                self.writer
                    .writeln(&format!("nameAddr := {}", self.reg(rs1)));
                self.writer
                    .writeln(&format!("valueAddr := {}", self.reg(rs2)));
                self.writer.writeln("name := readString(nameAddr)");
                self.writer.writeln("value := os.Getenv(name)");
                self.writer.writeln("var length uint64");
                self.writer
                    .writeln("if valueAddr+uint64(len(value))+1 <= uint64(len(memory)) {");
                self.writer.indent();
                self.writer
                    .writeln("copy(memory[valueAddr:], []byte(value))");
                self.writer
                    .writeln("memory[valueAddr+uint64(len(value))] = 0 // null terminate");
                self.writer.writeln("length = uint64(len(value))");
                self.writer.dedent();
                self.writer.writeln("}");
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!("{} = length", dst));
                }
                self.writer.dedent();
                self.writer.writeln("}");
            }
        }
        Ok(())
    }

    fn emit_time(&mut self, op: TimeOp, rd: Register, imm: Option<i32>) -> CodeGenResult<()> {
        match op {
            TimeOp::Now => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer
                        .writeln(&format!("{} = uint64(time.Now().Unix())", dst));
                }
            }
            TimeOp::Sleep => {
                let ms = imm.unwrap_or(0);
                self.writer
                    .writeln(&format!("time.Sleep({}*time.Millisecond)", ms));
            }
            TimeOp::Monotonic => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer
                        .writeln(&format!("{} = uint64(time.Now().UnixNano())", dst));
                }
            }
            _ => {}
        }
        Ok(())
    }

    fn emit_fpu(
        &mut self,
        op: FpuOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            match op {
                // Arithmetic operations return double bit pattern
                FpuOp::Fadd
                | FpuOp::Fsub
                | FpuOp::Fmul
                | FpuOp::Fdiv
                | FpuOp::Fsqrt
                | FpuOp::Fabs
                | FpuOp::Ffloor
                | FpuOp::Fceil => {
                    let expr = match op {
                        FpuOp::Fadd => format!(
                            "math.Float64frombits({}) + math.Float64frombits({})",
                            self.reg(rs1),
                            self.reg(rs2)
                        ),
                        FpuOp::Fsub => format!(
                            "math.Float64frombits({}) - math.Float64frombits({})",
                            self.reg(rs1),
                            self.reg(rs2)
                        ),
                        FpuOp::Fmul => format!(
                            "math.Float64frombits({}) * math.Float64frombits({})",
                            self.reg(rs1),
                            self.reg(rs2)
                        ),
                        FpuOp::Fdiv => format!(
                            "math.Float64frombits({}) / math.Float64frombits({})",
                            self.reg(rs1),
                            self.reg(rs2)
                        ),
                        FpuOp::Fsqrt => {
                            format!("math.Sqrt(math.Float64frombits({}))", self.reg(rs1))
                        }
                        FpuOp::Fabs => format!("math.Abs(math.Float64frombits({}))", self.reg(rs1)),
                        FpuOp::Ffloor => {
                            format!("math.Floor(math.Float64frombits({}))", self.reg(rs1))
                        }
                        FpuOp::Fceil => {
                            format!("math.Ceil(math.Float64frombits({}))", self.reg(rs1))
                        }
                        _ => unreachable!(),
                    };
                    self.writer
                        .writeln(&format!("{} = math.Float64bits({})", dst, expr));
                }
                // Comparison operations return integer 1 or 0
                FpuOp::Fcmpeq => {
                    self.writer.writeln(&format!("if math.Float64frombits({}) == math.Float64frombits({}) {{ {} = 1 }} else {{ {} = 0 }}", self.reg(rs1), self.reg(rs2), dst, dst));
                }
                FpuOp::Fcmpne => {
                    self.writer.writeln(&format!("if math.Float64frombits({}) != math.Float64frombits({}) {{ {} = 1 }} else {{ {} = 0 }}", self.reg(rs1), self.reg(rs2), dst, dst));
                }
                FpuOp::Fcmplt => {
                    self.writer.writeln(&format!("if math.Float64frombits({}) < math.Float64frombits({}) {{ {} = 1 }} else {{ {} = 0 }}", self.reg(rs1), self.reg(rs2), dst, dst));
                }
                FpuOp::Fcmple => {
                    self.writer.writeln(&format!("if math.Float64frombits({}) <= math.Float64frombits({}) {{ {} = 1 }} else {{ {} = 0 }}", self.reg(rs1), self.reg(rs2), dst, dst));
                }
                FpuOp::Fcmpgt => {
                    self.writer.writeln(&format!("if math.Float64frombits({}) > math.Float64frombits({}) {{ {} = 1 }} else {{ {} = 0 }}", self.reg(rs1), self.reg(rs2), dst, dst));
                }
                FpuOp::Fcmpge => {
                    self.writer.writeln(&format!("if math.Float64frombits({}) >= math.Float64frombits({}) {{ {} = 1 }} else {{ {} = 0 }}", self.reg(rs1), self.reg(rs2), dst, dst));
                }
            }
        }
        Ok(())
    }

    fn emit_rand(&mut self, op: RandOp, rd: Register, rs1: Register) -> CodeGenResult<()> {
        match op {
            RandOp::RandU64 => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!("{} = rand.Uint64()", dst));
                }
            }
            RandOp::RandBytes => {
                self.writer.writeln(&format!(
                    "rand.Read(memory[{}:{}+{}])",
                    self.reg(rd),
                    self.reg(rd),
                    self.reg(rs1)
                ));
            }
        }
        Ok(())
    }

    fn emit_bits(&mut self, op: BitsOp, rd: Register, rs1: Register) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            let expr = match op {
                BitsOp::Popcount => format!("uint64(bits.OnesCount64({}))", self.reg(rs1)),
                BitsOp::Clz => format!("uint64(bits.LeadingZeros64({}))", self.reg(rs1)),
                BitsOp::Ctz => format!("uint64(bits.TrailingZeros64({}))", self.reg(rs1)),
                BitsOp::Bswap => format!("bits.ReverseBytes64({})", self.reg(rs1)),
            };
            self.writer.writeln(&format!("{} = {}", dst, expr));
        }
        Ok(())
    }

    fn emit_mov(&mut self, rd: Register, rs1: Register, imm: Option<i32>) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            if rs1 != Register::Zero {
                self.writer.writeln(&format!("{} = {}", dst, self.reg(rs1)));
            } else if let Some(i) = imm {
                self.writer
                    .writeln(&format!("{} = {}", dst, format_number(i)));
            } else {
                self.writer.writeln(&format!("{} = 0", dst));
            }
        }
        Ok(())
    }

    fn emit_trap(&mut self, trap_type: TrapType, imm: Option<i32>) -> CodeGenResult<()> {
        let code = imm.unwrap_or(0);
        match trap_type {
            TrapType::Syscall => {
                self.writer.writeln(&format!(
                    "fmt.Fprintf(os.Stderr, \"SYSCALL: System call %d (not implemented)\\n\", {})",
                    code
                ));
            }
            TrapType::Breakpoint => {
                self.writer.writeln(&format!(
                    "fmt.Fprintf(os.Stderr, \"BREAKPOINT: Hit breakpoint %d\\n\", {})",
                    code
                ));
            }
            TrapType::BoundsViolation => {
                self.writer
                    .writeln("fmt.Fprintln(os.Stderr, \"TRAP: Memory access out of bounds\")");
                self.writer.writeln("os.Exit(1)");
            }
            TrapType::CapabilityViolation => {
                self.writer
                    .writeln("fmt.Fprintln(os.Stderr, \"TRAP: Capability violation\")");
                self.writer.writeln("os.Exit(1)");
            }
            TrapType::TaintViolation => {
                self.writer
                    .writeln("fmt.Fprintln(os.Stderr, \"TRAP: Taint violation\")");
                self.writer.writeln("os.Exit(1)");
            }
            TrapType::DivByZero => {
                self.writer
                    .writeln("fmt.Fprintln(os.Stderr, \"TRAP: Division by zero\")");
                self.writer.writeln("os.Exit(1)");
            }
            TrapType::InvalidOp => {
                self.writer
                    .writeln("fmt.Fprintln(os.Stderr, \"TRAP: Invalid operation\")");
                self.writer.writeln("os.Exit(1)");
            }
            TrapType::User => {
                self.writer.writeln(&format!(
                    "fmt.Fprintf(os.Stderr, \"TRAP: User trap with code %d\\n\", {})",
                    code
                ));
                self.writer.writeln(&format!("os.Exit({})", code));
            }
        }
        Ok(())
    }

    fn emit_nop(&mut self) -> CodeGenResult<()> {
        self.writer.writeln("// nop");
        Ok(())
    }

    fn emit_halt(&mut self) -> CodeGenResult<()> {
        self.writer.writeln("return // halt");
        Ok(())
    }

    fn emit_ext_call(
        &mut self,
        rd: Register,
        ext_id: i32,
        rs1: Register,
        rs2: Register,
    ) -> CodeGenResult<()> {
        // Emit descriptive comment for known extension IDs
        let ext_desc = match ext_id {
            0 => "// ext.0: No-op / identity function",
            1 => "// ext.1: Memory allocation (rs1=size) -> returns address",
            2 => "// ext.2: Memory deallocation (rs1=address)",
            3 => "// ext.3: String length (rs1=string address) -> returns length",
            4 => "// ext.4: String copy (rs1=dest, rs2=src) -> returns bytes copied",
            5 => "// ext.5: String compare (rs1=str1, rs2=str2) -> returns comparison result",
            6 => "// ext.6: Memory copy (rs1=dest, rs2=src, imm=length) -> returns bytes copied",
            7 => "// ext.7: Memory set (rs1=dest, rs2=value, imm=length)",
            8 => "// ext.8: Memory compare (rs1=ptr1, rs2=ptr2, imm=length) -> returns comparison",
            10 => "// ext.10: Parse integer (rs1=string address) -> returns parsed value",
            11 => "// ext.11: Format integer (rs1=value, rs2=buffer address) -> returns string length",
            12 => "// ext.12: Parse float (rs1=string address) -> returns float bits",
            13 => "// ext.13: Format float (rs1=float bits, rs2=buffer address) -> returns string length",
            20 => "// ext.20: Hash function (rs1=data address, rs2=length) -> returns hash",
            21 => "// ext.21: CRC32 (rs1=data address, rs2=length) -> returns CRC",
            30 => "// ext.30: Compress (rs1=src, rs2=dest) -> returns compressed size",
            31 => "// ext.31: Decompress (rs1=src, rs2=dest) -> returns decompressed size",
            40 => "// ext.40: JSON parse (rs1=json string) -> returns object handle",
            41 => "// ext.41: JSON stringify (rs1=object handle, rs2=buffer) -> returns string length",
            50 => "// ext.50: Regex match (rs1=pattern, rs2=string) -> returns 1 if match, 0 otherwise",
            51 => "// ext.51: Regex replace (rs1=pattern, rs2=replacement) -> returns new string address",
            100 => "// ext.100: FFI call setup (rs1=function pointer)",
            101 => "// ext.101: FFI call invoke (rs1=arg1, rs2=arg2) -> returns result",
            200 => "// ext.200: GPU compute dispatch (rs1=kernel, rs2=work size)",
            201 => "// ext.201: GPU memory copy to device (rs1=host ptr, rs2=device ptr)",
            202 => "// ext.202: GPU memory copy from device (rs1=device ptr, rs2=host ptr)",
            _ => "// ext: Unknown extension function",
        };

        self.writer.writeln(ext_desc);
        self.writer.writeln(&format!(
            "// ext.call {} = ext_{}({}, {})",
            register_name(rd),
            ext_id,
            self.reg(rs1),
            self.reg(rs2)
        ));

        // Generate placeholder implementation with extension-specific behavior
        self.writer.writeln("{");
        self.writer.indent();
        self.writer.writeln(&format!("extID := {}", ext_id));
        self.writer.writeln(&format!("arg1 := {}", self.reg(rs1)));
        self.writer.writeln(&format!("arg2 := {}", self.reg(rs2)));
        self.writer.writeln("var result uint64");
        self.writer.writeln("switch extID {");
        self.writer.writeln("case 0: result = arg1 // identity");
        self.writer.writeln("case 3: // strlen");
        self.writer.indent();
        self.writer.writeln("s := readString(arg1)");
        self.writer.writeln("result = uint64(len(s))");
        self.writer.dedent();
        self.writer.writeln("default:");
        self.writer.indent();
        self.writer.writeln("_ = arg2 // suppress unused warning");
        self.writer.writeln("result = 0 // unimplemented extension");
        self.writer.dedent();
        self.writer.writeln("}");
        if let Some(dst) = self.reg_assign(rd) {
            self.writer.writeln(&format!("{} = result", dst));
        }
        self.writer.dedent();
        self.writer.writeln("}");
        Ok(())
    }

    fn emit_label(&mut self, index: usize) -> CodeGenResult<()> {
        self.writer.writeln(&format!("L{}:", index));
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::Assembler;

    #[test]
    fn test_go_generator_simple() {
        let mut asm = Assembler::new();
        let program = asm.assemble("mov r0, 42\nhalt").unwrap();

        let mut gen = GoCodeGenerator::new();
        let code = gen.generate(&program).unwrap();

        assert!(code.contains("package main"));
        assert!(code.contains("regs[0] = 42"));
        assert!(code.contains("return // halt"));
    }

    #[test]
    fn test_go_generator_alu() {
        let mut asm = Assembler::new();
        let program = asm.assemble("add r0, r1, r2\nsub r3, r0, r1").unwrap();

        let mut gen = GoCodeGenerator::new();
        let code = gen.generate(&program).unwrap();

        assert!(code.contains("regs[0] = regs[1] + regs[2]"));
        assert!(code.contains("regs[3] = regs[0] - regs[1]"));
    }
}
