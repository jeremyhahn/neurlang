//! C Code Generator for Neurlang IR
//!
//! Translates Neurlang IR to portable C99 code. This is the most direct
//! mapping since both languages share similar low-level memory semantics.
//!
//! # Output Structure
//!
//! ```c
//! #include <stdint.h>
//! #include <stdio.h>
//! // ... other includes
//!
//! // Register file
//! static uint64_t regs[32];
//! static uint8_t* memory;
//!
//! void execute(void) {
//!     // Generated code
//! }
//!
//! int main(void) {
//!     // Setup and execute
//! }
//! ```

use super::common::{
    analyze_branch_targets, format_number, CodeGenContext, CodeGenOptions, IndentWriter,
};
use super::{CodeGenError, CodeGenResult, CodeGenerator};
use crate::ir::{
    AluOp, AtomicOp, BitsOp, BranchCond, ChanOp, FenceMode, FileOp, FpuOp, Instruction, IoOp,
    MemWidth, MulDivOp, NetOp, Opcode, Program, RandOp, Register, TimeOp, TrapType,
};

/// C code generator
pub struct CCodeGenerator {
    writer: IndentWriter,
    context: CodeGenContext,
    options: CodeGenOptions,
}

impl CCodeGenerator {
    /// Create a new C code generator
    pub fn new() -> Self {
        Self {
            writer: IndentWriter::new(),
            context: CodeGenContext::new(0),
            options: CodeGenOptions::default(),
        }
    }

    /// Create with custom options
    pub fn with_options(options: CodeGenOptions) -> Self {
        Self {
            writer: IndentWriter::with_options(options.clone()),
            context: CodeGenContext::new(0),
            options,
        }
    }

    /// Get the ALU operation as a C operator
    fn alu_op_str(op: AluOp) -> &'static str {
        match op {
            AluOp::Add => "+",
            AluOp::Sub => "-",
            AluOp::And => "&",
            AluOp::Or => "|",
            AluOp::Xor => "^",
            AluOp::Shl => "<<",
            AluOp::Shr => ">>",
            AluOp::Sar => ">>", // Note: signed shift in C depends on type
        }
    }

    /// Get the branch condition as a C operator
    fn branch_cond_str(cond: BranchCond) -> &'static str {
        match cond {
            BranchCond::Always => "1",
            BranchCond::Eq => "==",
            BranchCond::Ne => "!=",
            BranchCond::Lt => "<",
            BranchCond::Le => "<=",
            BranchCond::Gt => ">",
            BranchCond::Ge => ">=",
            BranchCond::Ltu => "<", // Unsigned comparison needs cast
        }
    }

    /// Write a register access
    fn reg(&self, r: Register) -> String {
        if r == Register::Zero {
            "0".to_string()
        } else {
            format!("regs[{}]", r as usize)
        }
    }

    /// Write a register assignment
    fn reg_assign(&self, r: Register) -> Option<String> {
        if r == Register::Zero || r == Register::Pc {
            None
        } else {
            Some(format!("regs[{}]", r as usize))
        }
    }
}

impl Default for CCodeGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl CodeGenerator for CCodeGenerator {
    fn target_name(&self) -> &'static str {
        "C"
    }

    fn file_extension(&self) -> &'static str {
        "c"
    }

    fn generate(&mut self, program: &Program) -> CodeGenResult<String> {
        self.context = CodeGenContext::new(program.instructions.len());
        self.context.branch_targets = analyze_branch_targets(program);
        self.writer = IndentWriter::with_options(self.options.clone());

        self.emit_prologue()?;

        // Emit all instructions
        for (index, instr) in program.instructions.iter().enumerate() {
            self.context.current_index = index;
            self.emit_instruction(instr, index)?;
        }

        self.emit_epilogue()?;

        Ok(self.writer.output().to_string())
    }

    fn emit_prologue(&mut self) -> CodeGenResult<()> {
        self.writer
            .writeln("/* Generated by Neurlang C Code Generator */");
        self.writer.newline();
        self.writer.writeln("#include <stdint.h>");
        self.writer.writeln("#include <stdio.h>");
        self.writer.writeln("#include <stdlib.h>");
        self.writer.writeln("#include <string.h>");
        self.writer.writeln("#include <stdatomic.h>");
        self.writer.writeln("#include <math.h>");
        self.writer.writeln("#include <time.h>");
        self.writer.writeln("#include <unistd.h>");
        self.writer.writeln("#include <pthread.h>");
        self.writer.writeln("#include <sched.h>");
        self.writer.writeln("#include <fcntl.h>");
        self.writer.writeln("#include <sys/stat.h>");
        self.writer.writeln("#include <sys/socket.h>");
        self.writer.writeln("#include <netinet/in.h>");
        self.writer.writeln("#include <arpa/inet.h>");
        self.writer.writeln("#include <netdb.h>");
        self.writer.writeln("#include <errno.h>");
        self.writer.newline();

        // Memory and register definitions
        self.writer
            .writeln("/* Register file: r0-r15, sp, fp, lr, pc, csp, cfp, reserved, zero */");
        self.writer.writeln("static uint64_t regs[32] = {0};");
        self.writer.writeln("static uint8_t* memory = NULL;");
        self.writer.writeln("static size_t memory_size = 0;");
        self.writer.newline();

        // Thread infrastructure
        self.writer.writeln("/* Thread infrastructure */");
        self.writer.writeln("#define MAX_THREADS 256");
        self.writer.writeln(
            "typedef struct { pthread_t thread; uint64_t result; int active; } nl_thread_t;",
        );
        self.writer
            .writeln("static nl_thread_t threads[MAX_THREADS] = {0};");
        self.writer.writeln("static int next_thread_id = 0;");
        self.writer.newline();

        // Channel infrastructure
        self.writer.writeln("/* Channel infrastructure */");
        self.writer.writeln("#define MAX_CHANNELS 256");
        self.writer.writeln("#define CHAN_BUF_SIZE 64");
        self.writer.writeln("typedef struct {");
        self.writer.indent();
        self.writer.writeln("pthread_mutex_t mutex;");
        self.writer.writeln("pthread_cond_t not_empty;");
        self.writer.writeln("pthread_cond_t not_full;");
        self.writer.writeln("uint64_t buffer[CHAN_BUF_SIZE];");
        self.writer.writeln("int head, tail, count;");
        self.writer.writeln("int closed;");
        self.writer.dedent();
        self.writer.writeln("} nl_channel_t;");
        self.writer
            .writeln("static nl_channel_t* channels[MAX_CHANNELS] = {0};");
        self.writer.writeln("static int next_channel_id = 0;");
        self.writer.newline();

        // Channel helper functions
        self.writer.writeln("static int chan_create(void) {");
        self.writer.indent();
        self.writer
            .writeln("if (next_channel_id >= MAX_CHANNELS) return -1;");
        self.writer
            .writeln("nl_channel_t* ch = (nl_channel_t*)calloc(1, sizeof(nl_channel_t));");
        self.writer.writeln("pthread_mutex_init(&ch->mutex, NULL);");
        self.writer
            .writeln("pthread_cond_init(&ch->not_empty, NULL);");
        self.writer
            .writeln("pthread_cond_init(&ch->not_full, NULL);");
        self.writer.writeln("channels[next_channel_id] = ch;");
        self.writer.writeln("return next_channel_id++;");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        self.writer
            .writeln("static int chan_send(int id, uint64_t value) {");
        self.writer.indent();
        self.writer
            .writeln("if (id < 0 || id >= MAX_CHANNELS || !channels[id]) return -1;");
        self.writer.writeln("nl_channel_t* ch = channels[id];");
        self.writer.writeln("pthread_mutex_lock(&ch->mutex);");
        self.writer.writeln("while (ch->count >= CHAN_BUF_SIZE && !ch->closed) pthread_cond_wait(&ch->not_full, &ch->mutex);");
        self.writer
            .writeln("if (ch->closed) { pthread_mutex_unlock(&ch->mutex); return -1; }");
        self.writer.writeln("ch->buffer[ch->tail] = value;");
        self.writer
            .writeln("ch->tail = (ch->tail + 1) % CHAN_BUF_SIZE;");
        self.writer.writeln("ch->count++;");
        self.writer.writeln("pthread_cond_signal(&ch->not_empty);");
        self.writer.writeln("pthread_mutex_unlock(&ch->mutex);");
        self.writer.writeln("return 0;");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        self.writer.writeln("static uint64_t chan_recv(int id) {");
        self.writer.indent();
        self.writer
            .writeln("if (id < 0 || id >= MAX_CHANNELS || !channels[id]) return 0;");
        self.writer.writeln("nl_channel_t* ch = channels[id];");
        self.writer.writeln("pthread_mutex_lock(&ch->mutex);");
        self.writer.writeln(
            "while (ch->count == 0 && !ch->closed) pthread_cond_wait(&ch->not_empty, &ch->mutex);",
        );
        self.writer
            .writeln("if (ch->count == 0) { pthread_mutex_unlock(&ch->mutex); return 0; }");
        self.writer
            .writeln("uint64_t value = ch->buffer[ch->head];");
        self.writer
            .writeln("ch->head = (ch->head + 1) % CHAN_BUF_SIZE;");
        self.writer.writeln("ch->count--;");
        self.writer.writeln("pthread_cond_signal(&ch->not_full);");
        self.writer.writeln("pthread_mutex_unlock(&ch->mutex);");
        self.writer.writeln("return value;");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        self.writer.writeln("static void chan_close(int id) {");
        self.writer.indent();
        self.writer
            .writeln("if (id < 0 || id >= MAX_CHANNELS || !channels[id]) return;");
        self.writer.writeln("nl_channel_t* ch = channels[id];");
        self.writer.writeln("pthread_mutex_lock(&ch->mutex);");
        self.writer.writeln("ch->closed = 1;");
        self.writer
            .writeln("pthread_cond_broadcast(&ch->not_empty);");
        self.writer
            .writeln("pthread_cond_broadcast(&ch->not_full);");
        self.writer.writeln("pthread_mutex_unlock(&ch->mutex);");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        // Helper macros
        self.writer.writeln("/* Register aliases */");
        for i in 0..16 {
            self.writer.writeln(&format!("#define r{} regs[{}]", i, i));
        }
        self.writer.writeln("#define sp regs[16]");
        self.writer.writeln("#define fp regs[17]");
        self.writer.writeln("#define lr regs[18]");
        self.writer.writeln("#define pc regs[19]");
        self.writer.writeln("#define zero 0ULL");
        self.writer.newline();

        // Memory access helpers
        if self.options.include_safety_checks {
            self.writer
                .writeln("/* Safe memory access with bounds checking */");
            self.writer
                .writeln("#define LOAD8(addr) (((addr) < memory_size) ? memory[addr] : 0)");
            self.writer.writeln(
                "#define LOAD16(addr) (((addr) + 1 < memory_size) ? *(uint16_t*)&memory[addr] : 0)",
            );
            self.writer.writeln(
                "#define LOAD32(addr) (((addr) + 3 < memory_size) ? *(uint32_t*)&memory[addr] : 0)",
            );
            self.writer.writeln(
                "#define LOAD64(addr) (((addr) + 7 < memory_size) ? *(uint64_t*)&memory[addr] : 0)",
            );
            self.writer.writeln("#define STORE8(addr, val) do { if ((addr) < memory_size) memory[addr] = (uint8_t)(val); } while(0)");
            self.writer.writeln("#define STORE16(addr, val) do { if ((addr) + 1 < memory_size) *(uint16_t*)&memory[addr] = (uint16_t)(val); } while(0)");
            self.writer.writeln("#define STORE32(addr, val) do { if ((addr) + 3 < memory_size) *(uint32_t*)&memory[addr] = (uint32_t)(val); } while(0)");
            self.writer.writeln("#define STORE64(addr, val) do { if ((addr) + 7 < memory_size) *(uint64_t*)&memory[addr] = (uint64_t)(val); } while(0)");
        } else {
            self.writer
                .writeln("/* Direct memory access (no bounds checking) */");
            self.writer.writeln("#define LOAD8(addr) memory[addr]");
            self.writer
                .writeln("#define LOAD16(addr) (*(uint16_t*)&memory[addr])");
            self.writer
                .writeln("#define LOAD32(addr) (*(uint32_t*)&memory[addr])");
            self.writer
                .writeln("#define LOAD64(addr) (*(uint64_t*)&memory[addr])");
            self.writer
                .writeln("#define STORE8(addr, val) (memory[addr] = (uint8_t)(val))");
            self.writer.writeln(
                "#define STORE16(addr, val) (*(uint16_t*)&memory[addr] = (uint16_t)(val))",
            );
            self.writer.writeln(
                "#define STORE32(addr, val) (*(uint32_t*)&memory[addr] = (uint32_t)(val))",
            );
            self.writer.writeln(
                "#define STORE64(addr, val) (*(uint64_t*)&memory[addr] = (uint64_t)(val))",
            );
        }
        self.writer.newline();

        // Execution function
        self.writer.writeln("static int execute(void) {");
        self.writer.indent();

        Ok(())
    }

    fn emit_epilogue(&mut self) -> CodeGenResult<()> {
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        // Main function
        self.writer.writeln("int main(int argc, char** argv) {");
        self.writer.indent();
        self.writer.writeln("/* Initialize memory */");
        self.writer.writeln("memory_size = 1024 * 1024; /* 1MB */");
        self.writer
            .writeln("memory = (uint8_t*)calloc(memory_size, 1);");
        self.writer.writeln("if (!memory) return 1;");
        self.writer.newline();
        self.writer.writeln("/* Initialize stack pointer */");
        self.writer.writeln("sp = memory_size - 8;");
        self.writer.newline();
        self.writer.writeln("/* Execute program */");
        self.writer.writeln("int result = execute();");
        self.writer.newline();
        self.writer.writeln("/* Return r0 as exit code */");
        self.writer.writeln("free(memory);");
        self.writer.writeln("return (int)r0;");
        self.writer.dedent();
        self.writer.writeln("}");

        Ok(())
    }

    fn emit_instruction(&mut self, instr: &Instruction, index: usize) -> CodeGenResult<()> {
        // Emit label if this is a branch target
        if self.context.is_branch_target(index) {
            self.writer.dedent();
            self.writer.writeln(&format!("L{}:", index));
            self.writer.indent();
        }

        match instr.opcode {
            Opcode::Alu => {
                let op = AluOp::from_u8(instr.mode).unwrap_or(AluOp::Add);
                self.emit_alu(op, instr.rd, instr.rs1, instr.rs2)?;
            }
            Opcode::AluI => {
                let op = AluOp::from_u8(instr.mode).unwrap_or(AluOp::Add);
                let imm = instr.imm.ok_or(CodeGenError::MissingImmediate(index))?;
                self.emit_alu_imm(op, instr.rd, instr.rs1, imm)?;
            }
            Opcode::MulDiv => {
                let op = MulDivOp::from_u8(instr.mode).unwrap_or(MulDivOp::Mul);
                self.emit_muldiv(op, instr.rd, instr.rs1, instr.rs2)?;
            }
            Opcode::Load => {
                let width = MemWidth::from_u8(instr.mode).unwrap_or(MemWidth::Double);
                let offset = instr.imm.unwrap_or(0);
                self.emit_load(width, instr.rd, instr.rs1, offset)?;
            }
            Opcode::Store => {
                let width = MemWidth::from_u8(instr.mode).unwrap_or(MemWidth::Double);
                let offset = instr.imm.unwrap_or(0);
                self.emit_store(width, instr.rd, instr.rs1, offset)?;
            }
            Opcode::Atomic => {
                let op = AtomicOp::from_u8(instr.mode).unwrap_or(AtomicOp::Cas);
                self.emit_atomic(op, instr.rd, instr.rs1, instr.rs2)?;
            }
            Opcode::Branch => {
                let cond = BranchCond::from_u8(instr.mode).unwrap_or(BranchCond::Always);
                let target = instr.imm.unwrap_or(0);
                self.emit_branch(cond, instr.rs1, instr.rs2, target)?;
            }
            Opcode::Call => {
                let target = instr.imm.unwrap_or(0);
                self.emit_call(target)?;
            }
            Opcode::Ret => self.emit_ret()?,
            Opcode::Jump => {
                let target = instr.imm.unwrap_or(0);
                self.emit_jump(target, instr.mode == 1)?;
            }
            Opcode::CapNew => self.emit_cap_new(instr.rd, instr.rs1, instr.rs2)?,
            Opcode::CapRestrict => self.emit_cap_restrict(instr.rd, instr.rs1, instr.rs2)?,
            Opcode::CapQuery => {
                let query = instr.imm.unwrap_or(0);
                self.emit_cap_query(instr.rd, instr.rs1, query)?;
            }
            Opcode::Spawn => {
                let target = instr.imm.unwrap_or(0);
                self.emit_spawn(instr.rd, target, instr.rs1)?;
            }
            Opcode::Join => self.emit_join(instr.rs1)?,
            Opcode::Chan => {
                let op = ChanOp::from_u8(instr.mode).unwrap_or(ChanOp::Create);
                self.emit_chan(op, instr.rd, instr.rs1)?;
            }
            Opcode::Fence => {
                let mode = FenceMode::from_u8(instr.mode).unwrap_or(FenceMode::SeqCst);
                self.emit_fence(mode)?;
            }
            Opcode::Yield => self.emit_yield()?,
            Opcode::Taint => self.emit_taint(instr.rd, instr.rs1)?,
            Opcode::Sanitize => self.emit_sanitize(instr.rd, instr.rs1)?,
            Opcode::File => {
                let op = FileOp::from_u8(instr.mode).unwrap_or(FileOp::Open);
                self.emit_file(op, instr.rd, instr.rs1, instr.rs2, instr.imm)?;
            }
            Opcode::Net => {
                let op = NetOp::from_u8(instr.mode).unwrap_or(NetOp::Socket);
                self.emit_net(op, instr.rd, instr.rs1, instr.rs2, instr.imm)?;
            }
            Opcode::NetSetopt => {
                self.writer.writeln(&format!(
                    "/* net.setopt {} = {} */",
                    self.reg(instr.rs1),
                    instr.imm.unwrap_or(0)
                ));
            }
            Opcode::Io => {
                let op = IoOp::from_u8(instr.mode).unwrap_or(IoOp::Print);
                self.emit_io(op, instr.rd, instr.rs1, instr.rs2)?;
            }
            Opcode::Time => {
                let op = TimeOp::from_u8(instr.mode).unwrap_or(TimeOp::Now);
                self.emit_time(op, instr.rd, instr.imm)?;
            }
            Opcode::Fpu => {
                let op = FpuOp::from_u8(instr.mode).unwrap_or(FpuOp::Fadd);
                self.emit_fpu(op, instr.rd, instr.rs1, instr.rs2)?;
            }
            Opcode::Rand => {
                let op = RandOp::from_u8(instr.mode).unwrap_or(RandOp::RandU64);
                self.emit_rand(op, instr.rd, instr.rs1)?;
            }
            Opcode::Bits => {
                let op = BitsOp::from_u8(instr.mode).unwrap_or(BitsOp::Popcount);
                self.emit_bits(op, instr.rd, instr.rs1)?;
            }
            Opcode::Mov => self.emit_mov(instr.rd, instr.rs1, instr.imm)?,
            Opcode::Trap => {
                let trap = TrapType::from_u8(instr.mode).unwrap_or(TrapType::User);
                self.emit_trap(trap, instr.imm)?;
            }
            Opcode::Nop => self.emit_nop()?,
            Opcode::Halt => self.emit_halt()?,
            Opcode::ExtCall => {
                let ext_id = instr.imm.unwrap_or(0);
                self.emit_ext_call(instr.rd, ext_id, instr.rs1, instr.rs2)?;
            }
        }

        Ok(())
    }

    fn emit_alu(
        &mut self,
        op: AluOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            let op_str = Self::alu_op_str(op);
            if op == AluOp::Sar {
                // Arithmetic right shift needs signed cast
                self.writer.writeln(&format!(
                    "{} = (uint64_t)((int64_t){} {} {});",
                    dst,
                    self.reg(rs1),
                    op_str,
                    self.reg(rs2)
                ));
            } else {
                self.writer.writeln(&format!(
                    "{} = {} {} {};",
                    dst,
                    self.reg(rs1),
                    op_str,
                    self.reg(rs2)
                ));
            }
        }
        Ok(())
    }

    fn emit_alu_imm(
        &mut self,
        op: AluOp,
        rd: Register,
        rs1: Register,
        imm: i32,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            let op_str = Self::alu_op_str(op);
            if op == AluOp::Sar {
                self.writer.writeln(&format!(
                    "{} = (uint64_t)((int64_t){} {} {});",
                    dst,
                    self.reg(rs1),
                    op_str,
                    imm
                ));
            } else {
                self.writer.writeln(&format!(
                    "{} = {} {} {};",
                    dst,
                    self.reg(rs1),
                    op_str,
                    format_number(imm)
                ));
            }
        }
        Ok(())
    }

    fn emit_muldiv(
        &mut self,
        op: MulDivOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            match op {
                MulDivOp::Mul => {
                    self.writer.writeln(&format!(
                        "{} = {} * {};",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                MulDivOp::MulH => {
                    self.writer.writeln(&format!(
                        "{} = (uint64_t)((__int128){} * {} >> 64);",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                MulDivOp::Div => {
                    if self.options.include_safety_checks {
                        self.writer.writeln(&format!(
                            "{} = {} ? {} / {} : 0;",
                            dst,
                            self.reg(rs2),
                            self.reg(rs1),
                            self.reg(rs2)
                        ));
                    } else {
                        self.writer.writeln(&format!(
                            "{} = {} / {};",
                            dst,
                            self.reg(rs1),
                            self.reg(rs2)
                        ));
                    }
                }
                MulDivOp::Mod => {
                    if self.options.include_safety_checks {
                        self.writer.writeln(&format!(
                            "{} = {} ? {} % {} : 0;",
                            dst,
                            self.reg(rs2),
                            self.reg(rs1),
                            self.reg(rs2)
                        ));
                    } else {
                        self.writer.writeln(&format!(
                            "{} = {} % {};",
                            dst,
                            self.reg(rs1),
                            self.reg(rs2)
                        ));
                    }
                }
            }
        }
        Ok(())
    }

    fn emit_load(
        &mut self,
        width: MemWidth,
        rd: Register,
        base: Register,
        offset: i32,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            let macro_name = match width {
                MemWidth::Byte => "LOAD8",
                MemWidth::Half => "LOAD16",
                MemWidth::Word => "LOAD32",
                MemWidth::Double => "LOAD64",
            };
            if offset != 0 {
                self.writer.writeln(&format!(
                    "{} = {}({} + {});",
                    dst,
                    macro_name,
                    self.reg(base),
                    format_number(offset)
                ));
            } else {
                self.writer
                    .writeln(&format!("{} = {}({});", dst, macro_name, self.reg(base)));
            }
        }
        Ok(())
    }

    fn emit_store(
        &mut self,
        width: MemWidth,
        src: Register,
        base: Register,
        offset: i32,
    ) -> CodeGenResult<()> {
        let macro_name = match width {
            MemWidth::Byte => "STORE8",
            MemWidth::Half => "STORE16",
            MemWidth::Word => "STORE32",
            MemWidth::Double => "STORE64",
        };
        if offset != 0 {
            self.writer.writeln(&format!(
                "{}({} + {}, {});",
                macro_name,
                self.reg(base),
                format_number(offset),
                self.reg(src)
            ));
        } else {
            self.writer.writeln(&format!(
                "{}({}, {});",
                macro_name,
                self.reg(base),
                self.reg(src)
            ));
        }
        Ok(())
    }

    fn emit_atomic(
        &mut self,
        op: AtomicOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            match op {
                AtomicOp::Cas => {
                    self.writer.writeln("{");
                    self.writer.indent();
                    self.writer
                        .writeln(&format!("uint64_t expected = {};", self.reg(rs2)));
                    self.writer.writeln(&format!(
                        "{} = atomic_compare_exchange_strong((_Atomic uint64_t*)(memory + {}), &expected, {}) ? 1 : 0;",
                        dst, self.reg(rs1), self.reg(rd)
                    ));
                    self.writer.dedent();
                    self.writer.writeln("}");
                }
                AtomicOp::Xchg => {
                    self.writer.writeln(&format!(
                        "{} = atomic_exchange((_Atomic uint64_t*)(memory + {}), {});",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                AtomicOp::Add => {
                    self.writer.writeln(&format!(
                        "{} = atomic_fetch_add((_Atomic uint64_t*)(memory + {}), {});",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                AtomicOp::And => {
                    self.writer.writeln(&format!(
                        "{} = atomic_fetch_and((_Atomic uint64_t*)(memory + {}), {});",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                AtomicOp::Or => {
                    self.writer.writeln(&format!(
                        "{} = atomic_fetch_or((_Atomic uint64_t*)(memory + {}), {});",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                AtomicOp::Xor => {
                    self.writer.writeln(&format!(
                        "{} = atomic_fetch_xor((_Atomic uint64_t*)(memory + {}), {});",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                AtomicOp::Min => {
                    // Implement atomic min using CAS loop
                    self.writer.writeln("{");
                    self.writer.indent();
                    self.writer.writeln(&format!(
                        "_Atomic uint64_t* ptr = (_Atomic uint64_t*)(memory + {});",
                        self.reg(rs1)
                    ));
                    self.writer
                        .writeln(&format!("uint64_t newval = {};", self.reg(rs2)));
                    self.writer.writeln("uint64_t oldval = atomic_load(ptr);");
                    self.writer.writeln("while (newval < oldval) {");
                    self.writer.indent();
                    self.writer
                        .writeln("if (atomic_compare_exchange_weak(ptr, &oldval, newval)) break;");
                    self.writer.dedent();
                    self.writer.writeln("}");
                    self.writer.writeln(&format!("{} = oldval;", dst));
                    self.writer.dedent();
                    self.writer.writeln("}");
                }
                AtomicOp::Max => {
                    // Implement atomic max using CAS loop
                    self.writer.writeln("{");
                    self.writer.indent();
                    self.writer.writeln(&format!(
                        "_Atomic uint64_t* ptr = (_Atomic uint64_t*)(memory + {});",
                        self.reg(rs1)
                    ));
                    self.writer
                        .writeln(&format!("uint64_t newval = {};", self.reg(rs2)));
                    self.writer.writeln("uint64_t oldval = atomic_load(ptr);");
                    self.writer.writeln("while (newval > oldval) {");
                    self.writer.indent();
                    self.writer
                        .writeln("if (atomic_compare_exchange_weak(ptr, &oldval, newval)) break;");
                    self.writer.dedent();
                    self.writer.writeln("}");
                    self.writer.writeln(&format!("{} = oldval;", dst));
                    self.writer.dedent();
                    self.writer.writeln("}");
                }
            }
        }
        Ok(())
    }

    fn emit_branch(
        &mut self,
        cond: BranchCond,
        rs1: Register,
        rs2: Register,
        target: i32,
    ) -> CodeGenResult<()> {
        let target_index = (self.context.current_index as i32 + target) as usize;
        self.context.mark_branch_target(target_index);

        match cond {
            BranchCond::Always => {
                self.writer.writeln(&format!("goto L{};", target_index));
            }
            BranchCond::Ltu => {
                // Unsigned comparison
                self.writer.writeln(&format!(
                    "if ((uint64_t){} < (uint64_t){}) goto L{};",
                    self.reg(rs1),
                    self.reg(rs2),
                    target_index
                ));
            }
            _ => {
                let op = Self::branch_cond_str(cond);
                self.writer.writeln(&format!(
                    "if ((int64_t){} {} (int64_t){}) goto L{};",
                    self.reg(rs1),
                    op,
                    self.reg(rs2),
                    target_index
                ));
            }
        }
        Ok(())
    }

    fn emit_call(&mut self, target: i32) -> CodeGenResult<()> {
        // For now, inline calls as gotos (no real call stack in generated C)
        let target_index = (self.context.current_index as i32 + target) as usize;
        self.context.mark_branch_target(target_index);
        self.writer.writeln(&format!(
            "lr = {}; /* save return address */",
            self.context.current_index + 1
        ));
        self.writer.writeln(&format!("goto L{};", target_index));
        Ok(())
    }

    fn emit_ret(&mut self) -> CodeGenResult<()> {
        self.writer.writeln("return 0; /* ret */");
        Ok(())
    }

    fn emit_jump(&mut self, target: i32, indirect: bool) -> CodeGenResult<()> {
        if indirect {
            self.writer
                .writeln("/* indirect jump not fully supported in C */");
            self.writer.writeln("return 0;");
        } else {
            let target_index = (self.context.current_index as i32 + target) as usize;
            self.context.mark_branch_target(target_index);
            self.writer.writeln(&format!("goto L{};", target_index));
        }
        Ok(())
    }

    fn emit_cap_new(&mut self, rd: Register, base: Register, len: Register) -> CodeGenResult<()> {
        // Capabilities are simplified in C - just track base/length
        if let Some(dst) = self.reg_assign(rd) {
            self.writer.writeln(&format!(
                "{} = {}; /* cap.new: base={}, len={} */",
                dst,
                self.reg(base),
                self.reg(base),
                self.reg(len)
            ));
        }
        Ok(())
    }

    fn emit_cap_restrict(
        &mut self,
        rd: Register,
        src: Register,
        len: Register,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            self.writer
                .writeln(&format!("{} = {}; /* cap.restrict */", dst, self.reg(src)));
        }
        let _ = len;
        Ok(())
    }

    fn emit_cap_query(
        &mut self,
        rd: Register,
        cap: Register,
        query_type: i32,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            self.writer.writeln(&format!(
                "{} = {}; /* cap.query type={} */",
                dst,
                self.reg(cap),
                query_type
            ));
        }
        Ok(())
    }

    fn emit_spawn(&mut self, rd: Register, target: i32, arg: Register) -> CodeGenResult<()> {
        let target_label = (self.context.current_index as i32 + target) as usize;
        if let Some(dst) = self.reg_assign(rd) {
            self.writer.writeln("{");
            self.writer.indent();
            self.writer.writeln("int tid = next_thread_id++;");
            self.writer.writeln("if (tid < MAX_THREADS) {");
            self.writer.indent();
            self.writer.writeln("threads[tid].active = 1;");
            self.writer
                .writeln(&format!("uint64_t spawn_arg = {};", self.reg(arg)));
            self.writer
                .writeln("/* Note: Full thread spawn requires code restructuring.");
            self.writer.writeln(&format!(
                "   Target: L{}, Arg stored in spawn_arg */",
                target_label
            ));
            self.writer.writeln(&format!("{} = tid;", dst));
            self.writer.dedent();
            self.writer.writeln("} else {");
            self.writer.indent();
            self.writer.writeln(&format!("{} = (uint64_t)-1;", dst));
            self.writer.dedent();
            self.writer.writeln("}");
            self.writer.dedent();
            self.writer.writeln("}");
        }
        Ok(())
    }

    fn emit_join(&mut self, task: Register) -> CodeGenResult<()> {
        self.writer.writeln("{");
        self.writer.indent();
        self.writer
            .writeln(&format!("int tid = (int){};", self.reg(task)));
        self.writer
            .writeln("if (tid >= 0 && tid < MAX_THREADS && threads[tid].active) {");
        self.writer.indent();
        self.writer
            .writeln("pthread_join(threads[tid].thread, NULL);");
        self.writer.writeln("threads[tid].active = 0;");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.dedent();
        self.writer.writeln("}");
        Ok(())
    }

    fn emit_chan(&mut self, op: ChanOp, rd: Register, rs1: Register) -> CodeGenResult<()> {
        match op {
            ChanOp::Create => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer
                        .writeln(&format!("{} = (uint64_t)chan_create();", dst));
                }
            }
            ChanOp::Send => {
                self.writer.writeln(&format!(
                    "chan_send((int){}, {});",
                    self.reg(rd),
                    self.reg(rs1)
                ));
            }
            ChanOp::Recv => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer
                        .writeln(&format!("{} = chan_recv((int){});", dst, self.reg(rs1)));
                }
            }
            ChanOp::Close => {
                self.writer
                    .writeln(&format!("chan_close((int){});", self.reg(rd)));
            }
        }
        Ok(())
    }

    fn emit_fence(&mut self, mode: FenceMode) -> CodeGenResult<()> {
        let order = match mode {
            FenceMode::Acquire => "memory_order_acquire",
            FenceMode::Release => "memory_order_release",
            FenceMode::AcqRel => "memory_order_acq_rel",
            FenceMode::SeqCst => "memory_order_seq_cst",
        };
        self.writer
            .writeln(&format!("atomic_thread_fence({});", order));
        Ok(())
    }

    fn emit_yield(&mut self) -> CodeGenResult<()> {
        self.writer.writeln("sched_yield();");
        Ok(())
    }

    fn emit_taint(&mut self, rd: Register, rs1: Register) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            self.writer
                .writeln(&format!("{} = {}; /* taint */", dst, self.reg(rs1)));
        }
        Ok(())
    }

    fn emit_sanitize(&mut self, rd: Register, rs1: Register) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            self.writer
                .writeln(&format!("{} = {}; /* sanitize */", dst, self.reg(rs1)));
        }
        Ok(())
    }

    fn emit_file(
        &mut self,
        op: FileOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
        imm: Option<i32>,
    ) -> CodeGenResult<()> {
        match op {
            FileOp::Open => {
                if let Some(dst) = self.reg_assign(rd) {
                    let mode = imm.unwrap_or(0);
                    let mode_str = match mode {
                        0 => "\"r\"",
                        1 => "\"w\"",
                        2 => "\"a\"",
                        3 => "\"r+\"",
                        4 => "\"w+\"",
                        _ => "\"r\"",
                    };
                    self.writer.writeln(&format!(
                        "{} = (uint64_t)fopen((char*)(memory + {}), {});",
                        dst,
                        self.reg(rs1),
                        mode_str
                    ));
                }
            }
            FileOp::Read => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!(
                        "{} = fread(memory + {}, 1, {}, (FILE*){});",
                        dst,
                        self.reg(rs2),
                        self.reg(rd),
                        self.reg(rs1)
                    ));
                }
            }
            FileOp::Write => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!(
                        "{} = fwrite(memory + {}, 1, {}, (FILE*){});",
                        dst,
                        self.reg(rs2),
                        self.reg(rd),
                        self.reg(rs1)
                    ));
                }
            }
            FileOp::Close => {
                self.writer
                    .writeln(&format!("fclose((FILE*){});", self.reg(rs1)));
            }
            FileOp::Seek => {
                if let Some(dst) = self.reg_assign(rd) {
                    let whence = imm.unwrap_or(0);
                    let whence_str = match whence {
                        0 => "SEEK_SET",
                        1 => "SEEK_CUR",
                        2 => "SEEK_END",
                        _ => "SEEK_SET",
                    };
                    self.writer.writeln(&format!(
                        "{} = fseek((FILE*){}, (long){}, {});",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2),
                        whence_str
                    ));
                }
            }
            FileOp::Stat => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln("{");
                    self.writer.indent();
                    self.writer.writeln("struct stat st;");
                    self.writer.writeln(&format!(
                        "if (stat((char*)(memory + {}), &st) == 0) {{",
                        self.reg(rs1)
                    ));
                    self.writer.indent();
                    self.writer.writeln(&format!("{} = st.st_size;", dst));
                    self.writer.dedent();
                    self.writer.writeln("} else {");
                    self.writer.indent();
                    self.writer.writeln(&format!("{} = (uint64_t)-1;", dst));
                    self.writer.dedent();
                    self.writer.writeln("}");
                    self.writer.dedent();
                    self.writer.writeln("}");
                }
            }
            FileOp::Mkdir => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!(
                        "{} = mkdir((char*)(memory + {}), 0755) == 0 ? 0 : (uint64_t)-1;",
                        dst,
                        self.reg(rs1)
                    ));
                }
            }
            FileOp::Delete => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!(
                        "{} = remove((char*)(memory + {})) == 0 ? 0 : (uint64_t)-1;",
                        dst,
                        self.reg(rs1)
                    ));
                }
            }
        }
        Ok(())
    }

    fn emit_net(
        &mut self,
        op: NetOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
        imm: Option<i32>,
    ) -> CodeGenResult<()> {
        match op {
            NetOp::Socket => {
                if let Some(dst) = self.reg_assign(rd) {
                    let sock_type = imm.unwrap_or(0);
                    let type_str = if sock_type == 1 {
                        "SOCK_DGRAM"
                    } else {
                        "SOCK_STREAM"
                    };
                    self.writer.writeln(&format!(
                        "{} = (uint64_t)socket(AF_INET, {}, 0);",
                        dst, type_str
                    ));
                }
            }
            NetOp::Connect => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln("{");
                    self.writer.indent();
                    self.writer.writeln("struct sockaddr_in addr;");
                    self.writer.writeln("memset(&addr, 0, sizeof(addr));");
                    self.writer.writeln("addr.sin_family = AF_INET;");
                    self.writer.writeln(&format!(
                        "addr.sin_port = htons((uint16_t){});",
                        self.reg(rs2)
                    ));
                    self.writer.writeln(&format!(
                        "addr.sin_addr.s_addr = htonl((uint32_t){});",
                        self.reg(rs1)
                    ));
                    self.writer.writeln(&format!(
                        "{} = connect((int){}, (struct sockaddr*)&addr, sizeof(addr)) == 0 ? 0 : (uint64_t)-1;",
                        dst, self.reg(rd)
                    ));
                    self.writer.dedent();
                    self.writer.writeln("}");
                }
            }
            NetOp::Bind => {
                if let Some(dst) = self.reg_assign(rd) {
                    let port = imm.unwrap_or(0);
                    self.writer.writeln("{");
                    self.writer.indent();
                    self.writer.writeln("struct sockaddr_in addr;");
                    self.writer.writeln("memset(&addr, 0, sizeof(addr));");
                    self.writer.writeln("addr.sin_family = AF_INET;");
                    self.writer
                        .writeln(&format!("addr.sin_port = htons({});", port));
                    self.writer.writeln("addr.sin_addr.s_addr = INADDR_ANY;");
                    self.writer.writeln(&format!(
                        "{} = bind((int){}, (struct sockaddr*)&addr, sizeof(addr)) == 0 ? 0 : (uint64_t)-1;",
                        dst, self.reg(rs1)
                    ));
                    self.writer.dedent();
                    self.writer.writeln("}");
                }
            }
            NetOp::Listen => {
                if let Some(dst) = self.reg_assign(rd) {
                    let backlog = imm.unwrap_or(128);
                    self.writer.writeln(&format!(
                        "{} = listen((int){}, {}) == 0 ? 0 : (uint64_t)-1;",
                        dst,
                        self.reg(rs1),
                        backlog
                    ));
                }
            }
            NetOp::Accept => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!(
                        "{} = (uint64_t)accept((int){}, NULL, NULL);",
                        dst,
                        self.reg(rs1)
                    ));
                }
            }
            NetOp::Send => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!(
                        "{} = send((int){}, memory + {}, {}, 0);",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2),
                        self.reg(rd)
                    ));
                }
            }
            NetOp::Recv => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!(
                        "{} = recv((int){}, memory + {}, {}, 0);",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2),
                        self.reg(rd)
                    ));
                }
            }
            NetOp::Close => {
                self.writer
                    .writeln(&format!("close((int){});", self.reg(rs1)));
            }
        }
        Ok(())
    }

    fn emit_io(
        &mut self,
        op: IoOp,
        _rd: Register,
        rs1: Register,
        rs2: Register,
    ) -> CodeGenResult<()> {
        match op {
            IoOp::Print => {
                self.writer.writeln(&format!(
                    "fwrite(memory + {}, 1, {}, stdout); fflush(stdout);",
                    self.reg(rs1),
                    self.reg(rs2)
                ));
            }
            IoOp::ReadLine => {
                self.writer.writeln(&format!(
                    "{{ char* p = fgets((char*)(memory + {}), (int){}, stdin); (void)p; }}",
                    self.reg(rs1),
                    self.reg(rs2)
                ));
            }
            IoOp::GetArgs => {
                self.writer
                    .writeln("/* io.getargs - argc/argv available from main */");
            }
            IoOp::GetEnv => {
                self.writer.writeln(&format!(
                    "{{ char* env = getenv((char*)(memory + {})); if (env) strcpy((char*)(memory + {}), env); }}",
                    self.reg(rs1), self.reg(rs2)
                ));
            }
        }
        Ok(())
    }

    fn emit_time(&mut self, op: TimeOp, rd: Register, imm: Option<i32>) -> CodeGenResult<()> {
        match op {
            TimeOp::Now => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer
                        .writeln(&format!("{} = (uint64_t)time(NULL);", dst));
                }
            }
            TimeOp::Sleep => {
                let ms = imm.unwrap_or(0);
                self.writer.writeln(&format!("usleep({} * 1000);", ms));
            }
            TimeOp::Monotonic => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!(
                        "{{ struct timespec ts; clock_gettime(CLOCK_MONOTONIC, &ts); {} = ts.tv_sec * 1000000000ULL + ts.tv_nsec; }}",
                        dst
                    ));
                }
            }
            _ => {}
        }
        Ok(())
    }

    fn emit_fpu(
        &mut self,
        op: FpuOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            match op {
                // Arithmetic operations return double bit pattern
                FpuOp::Fadd
                | FpuOp::Fsub
                | FpuOp::Fmul
                | FpuOp::Fdiv
                | FpuOp::Fsqrt
                | FpuOp::Fabs
                | FpuOp::Ffloor
                | FpuOp::Fceil => {
                    let expr = match op {
                        FpuOp::Fadd => format!(
                            "*(double*)&{} + *(double*)&{}",
                            self.reg(rs1),
                            self.reg(rs2)
                        ),
                        FpuOp::Fsub => format!(
                            "*(double*)&{} - *(double*)&{}",
                            self.reg(rs1),
                            self.reg(rs2)
                        ),
                        FpuOp::Fmul => format!(
                            "*(double*)&{} * *(double*)&{}",
                            self.reg(rs1),
                            self.reg(rs2)
                        ),
                        FpuOp::Fdiv => format!(
                            "*(double*)&{} / *(double*)&{}",
                            self.reg(rs1),
                            self.reg(rs2)
                        ),
                        FpuOp::Fsqrt => format!("sqrt(*(double*)&{})", self.reg(rs1)),
                        FpuOp::Fabs => format!("fabs(*(double*)&{})", self.reg(rs1)),
                        FpuOp::Ffloor => format!("floor(*(double*)&{})", self.reg(rs1)),
                        FpuOp::Fceil => format!("ceil(*(double*)&{})", self.reg(rs1)),
                        _ => unreachable!(),
                    };
                    self.writer.writeln(&format!(
                        "{{ double _r = {}; memcpy(&{}, &_r, 8); }}",
                        expr, dst
                    ));
                }
                // Comparison operations return integer 1 or 0
                FpuOp::Fcmpeq => {
                    self.writer.writeln(&format!(
                        "{} = (*(double*)&{} == *(double*)&{}) ? 1 : 0;",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                FpuOp::Fcmpne => {
                    self.writer.writeln(&format!(
                        "{} = (*(double*)&{} != *(double*)&{}) ? 1 : 0;",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                FpuOp::Fcmplt => {
                    self.writer.writeln(&format!(
                        "{} = (*(double*)&{} < *(double*)&{}) ? 1 : 0;",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                FpuOp::Fcmple => {
                    self.writer.writeln(&format!(
                        "{} = (*(double*)&{} <= *(double*)&{}) ? 1 : 0;",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                FpuOp::Fcmpgt => {
                    self.writer.writeln(&format!(
                        "{} = (*(double*)&{} > *(double*)&{}) ? 1 : 0;",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                FpuOp::Fcmpge => {
                    self.writer.writeln(&format!(
                        "{} = (*(double*)&{} >= *(double*)&{}) ? 1 : 0;",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
            }
        }
        Ok(())
    }

    fn emit_rand(&mut self, op: RandOp, rd: Register, rs1: Register) -> CodeGenResult<()> {
        match op {
            RandOp::RandU64 => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer
                        .writeln(&format!("{} = ((uint64_t)rand() << 32) | rand();", dst));
                }
            }
            RandOp::RandBytes => {
                self.writer.writeln(&format!(
                    "for (size_t i = 0; i < {}; i++) memory[{} + i] = rand() & 0xFF;",
                    self.reg(rs1),
                    self.reg(rd)
                ));
            }
        }
        Ok(())
    }

    fn emit_bits(&mut self, op: BitsOp, rd: Register, rs1: Register) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            let expr = match op {
                BitsOp::Popcount => format!("__builtin_popcountll({})", self.reg(rs1)),
                BitsOp::Clz => format!(
                    "{} ? __builtin_clzll({}) : 64",
                    self.reg(rs1),
                    self.reg(rs1)
                ),
                BitsOp::Ctz => format!(
                    "{} ? __builtin_ctzll({}) : 64",
                    self.reg(rs1),
                    self.reg(rs1)
                ),
                BitsOp::Bswap => format!("__builtin_bswap64({})", self.reg(rs1)),
            };
            self.writer.writeln(&format!("{} = {};", dst, expr));
        }
        Ok(())
    }

    fn emit_mov(&mut self, rd: Register, rs1: Register, imm: Option<i32>) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            if rs1 != Register::Zero {
                self.writer
                    .writeln(&format!("{} = {};", dst, self.reg(rs1)));
            } else if let Some(i) = imm {
                self.writer
                    .writeln(&format!("{} = {};", dst, format_number(i)));
            } else {
                self.writer.writeln(&format!("{} = 0;", dst));
            }
        }
        Ok(())
    }

    fn emit_trap(&mut self, trap_type: TrapType, imm: Option<i32>) -> CodeGenResult<()> {
        match trap_type {
            TrapType::Syscall => {
                let syscall_num = imm.unwrap_or(0);
                self.writer.writeln(&format!(
                    "{{ fprintf(stderr, \"TRAP: syscall %d\\n\", {}); exit(1); }}",
                    syscall_num
                ));
            }
            TrapType::Breakpoint => {
                self.writer
                    .writeln("#if defined(__x86_64__) || defined(__i386__)");
                self.writer.writeln("__asm__(\"int $3\");");
                self.writer.writeln("#elif defined(__aarch64__)");
                self.writer.writeln("__asm__(\"brk #0\");");
                self.writer.writeln("#else");
                self.writer.writeln("raise(SIGTRAP);");
                self.writer.writeln("#endif");
            }
            TrapType::BoundsViolation => {
                self.writer
                    .writeln("{ fprintf(stderr, \"TRAP: bounds violation\\n\"); exit(2); }");
            }
            TrapType::CapabilityViolation => {
                self.writer
                    .writeln("{ fprintf(stderr, \"TRAP: capability violation\\n\"); exit(3); }");
            }
            TrapType::TaintViolation => {
                self.writer
                    .writeln("{ fprintf(stderr, \"TRAP: taint violation\\n\"); exit(4); }");
            }
            TrapType::DivByZero => {
                self.writer
                    .writeln("{ fprintf(stderr, \"TRAP: division by zero\\n\"); exit(5); }");
            }
            TrapType::InvalidOp => {
                self.writer
                    .writeln("{ fprintf(stderr, \"TRAP: invalid operation\\n\"); exit(6); }");
            }
            TrapType::User => {
                let code = imm.unwrap_or(0);
                self.writer.writeln(&format!(
                    "{{ fprintf(stderr, \"TRAP: user trap %d\\n\", {}); exit(7); }}",
                    code
                ));
            }
        }
        Ok(())
    }

    fn emit_nop(&mut self) -> CodeGenResult<()> {
        self.writer.writeln("/* nop */");
        Ok(())
    }

    fn emit_halt(&mut self) -> CodeGenResult<()> {
        self.writer.writeln("return 0; /* halt */");
        Ok(())
    }

    fn emit_ext_call(
        &mut self,
        rd: Register,
        ext_id: i32,
        rs1: Register,
        rs2: Register,
    ) -> CodeGenResult<()> {
        // Map extension IDs to built-in functions
        if let Some(dst) = self.reg_assign(rd) {
            match ext_id {
                // SHA-256 hash
                1 => {
                    self.writer.writeln(&format!(
                        "/* ext: sha256 - hash {} bytes at {} into {} */",
                        self.reg(rs2),
                        self.reg(rs1),
                        dst
                    ));
                    self.writer.writeln(&format!(
                        "{} = 0; /* requires linking with crypto lib */",
                        dst
                    ));
                }
                // AES-256 encrypt
                2 => {
                    self.writer.writeln(&format!(
                        "/* ext: aes256_encrypt - encrypt {} bytes at {} */",
                        self.reg(rs2),
                        self.reg(rs1)
                    ));
                    self.writer.writeln(&format!("{} = 0;", dst));
                }
                // Base64 encode
                10 => {
                    self.writer.writeln(&format!(
                        "/* ext: base64_encode - encode {} bytes at {} */",
                        self.reg(rs2),
                        self.reg(rs1)
                    ));
                    self.writer.writeln(&format!("{} = 0;", dst));
                }
                // JSON parse
                20 => {
                    self.writer.writeln(&format!(
                        "/* ext: json_parse - parse JSON at {} */",
                        self.reg(rs1)
                    ));
                    self.writer.writeln(&format!("{} = 0;", dst));
                }
                // Default: unknown extension
                _ => {
                    self.writer.writeln(&format!(
                        "/* ext: unknown extension {} with args {}, {} */",
                        ext_id,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                    self.writer.writeln(&format!("{} = (uint64_t)-1;", dst));
                }
            }
        }
        Ok(())
    }

    fn emit_label(&mut self, index: usize) -> CodeGenResult<()> {
        self.writer.writeln(&format!("L{}:", index));
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::Assembler;

    #[test]
    fn test_c_generator_simple() {
        let mut asm = Assembler::new();
        let program = asm.assemble("mov r0, 42\nhalt").unwrap();

        let mut gen = CCodeGenerator::new();
        let code = gen.generate(&program).unwrap();

        assert!(code.contains("#include <stdint.h>"));
        assert!(code.contains("regs[0] = 42"));
        assert!(code.contains("return 0; /* halt */"));
    }

    #[test]
    fn test_c_generator_alu() {
        let mut asm = Assembler::new();
        let program = asm.assemble("add r0, r1, r2\nsub r3, r0, r1").unwrap();

        let mut gen = CCodeGenerator::new();
        let code = gen.generate(&program).unwrap();

        assert!(code.contains("regs[0] = regs[1] + regs[2]"));
        assert!(code.contains("regs[3] = regs[0] - regs[1]"));
    }

    #[test]
    fn test_c_generator_branch() {
        let mut asm = Assembler::new();
        let program = asm
            .assemble("mov r0, 0\nloop:\nadd r0, r0, r1\nbne r0, r2, loop\nhalt")
            .unwrap();

        let mut gen = CCodeGenerator::new();
        let code = gen.generate(&program).unwrap();

        assert!(code.contains("goto L1"));
        assert!(code.contains("L1:"));
    }
}
