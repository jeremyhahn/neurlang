//! Rust Code Generator for Neurlang IR
//!
//! Translates Neurlang IR to safe Rust code. This generator emphasizes
//! Rust's safety guarantees while maintaining efficiency.
//!
//! # Features
//!
//! - Memory-safe bounds checking via slices
//! - std::sync::atomic for atomic operations
//! - std::thread for spawn/join
//! - std::sync::mpsc for channels

use super::common::{
    analyze_branch_targets, format_number, register_name, CodeGenContext, CodeGenOptions,
    IndentWriter,
};
use super::{CodeGenError, CodeGenResult, CodeGenerator};
use crate::ir::{
    AluOp, AtomicOp, BitsOp, BranchCond, ChanOp, FenceMode, FileOp, FpuOp, Instruction, IoOp,
    MemWidth, MulDivOp, NetOp, Opcode, Program, RandOp, Register, TimeOp, TrapType,
};

/// Rust code generator
pub struct RustCodeGenerator {
    writer: IndentWriter,
    context: CodeGenContext,
    options: CodeGenOptions,
}

impl RustCodeGenerator {
    /// Create a new Rust code generator
    pub fn new() -> Self {
        Self {
            writer: IndentWriter::new(),
            context: CodeGenContext::new(0),
            options: CodeGenOptions::default(),
        }
    }

    /// Create with custom options
    pub fn with_options(options: CodeGenOptions) -> Self {
        Self {
            writer: IndentWriter::with_options(options.clone()),
            context: CodeGenContext::new(0),
            options,
        }
    }

    /// Get the ALU operation as a Rust operator
    fn alu_op_str(op: AluOp) -> &'static str {
        match op {
            AluOp::Add => "wrapping_add",
            AluOp::Sub => "wrapping_sub",
            AluOp::And => "&",
            AluOp::Or => "|",
            AluOp::Xor => "^",
            AluOp::Shl => "<<",
            AluOp::Shr => ">>",
            AluOp::Sar => ">>", // For signed shift
        }
    }

    /// Get the branch condition as a Rust operator
    fn branch_cond_str(cond: BranchCond) -> &'static str {
        match cond {
            BranchCond::Always => "true",
            BranchCond::Eq => "==",
            BranchCond::Ne => "!=",
            BranchCond::Lt => "<",
            BranchCond::Le => "<=",
            BranchCond::Gt => ">",
            BranchCond::Ge => ">=",
            BranchCond::Ltu => "<",
        }
    }

    /// Write a register access
    fn reg(&self, r: Register) -> String {
        if r == Register::Zero {
            "0".to_string()
        } else {
            format!("regs[{}]", r as usize)
        }
    }

    /// Write a register assignment
    fn reg_assign(&self, r: Register) -> Option<String> {
        if r == Register::Zero || r == Register::Pc {
            None
        } else {
            Some(format!("regs[{}]", r as usize))
        }
    }
}

impl Default for RustCodeGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl CodeGenerator for RustCodeGenerator {
    fn target_name(&self) -> &'static str {
        "Rust"
    }

    fn file_extension(&self) -> &'static str {
        "rs"
    }

    fn generate(&mut self, program: &Program) -> CodeGenResult<String> {
        self.context = CodeGenContext::new(program.instructions.len());
        self.context.branch_targets = analyze_branch_targets(program);
        self.writer = IndentWriter::with_options(self.options.clone());

        self.emit_prologue()?;

        // Emit all instructions
        for (index, instr) in program.instructions.iter().enumerate() {
            self.context.current_index = index;
            self.emit_instruction(instr, index)?;
        }

        self.emit_epilogue()?;

        Ok(self.writer.output().to_string())
    }

    fn emit_prologue(&mut self) -> CodeGenResult<()> {
        self.writer
            .writeln("//! Generated by Neurlang Rust Code Generator");
        self.writer.newline();
        self.writer.writeln("#![allow(unused_variables)]");
        self.writer.writeln("#![allow(unused_mut)]");
        self.writer.writeln("#![allow(dead_code)]");
        self.writer.writeln("#![allow(unreachable_code)]");
        self.writer.newline();

        self.writer
            .writeln("use std::sync::atomic::{AtomicU64, Ordering};");
        self.writer
            .writeln("use std::sync::mpsc::{self, Sender, Receiver};");
        self.writer
            .writeln("use std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};");
        self.writer
            .writeln("use std::io::{self, Read, Write, Seek, SeekFrom};");
        self.writer
            .writeln("use std::fs::{self, File, OpenOptions};");
        self.writer
            .writeln("use std::net::{TcpStream, TcpListener, UdpSocket};");
        self.writer.writeln("use std::thread::{self, JoinHandle};");
        self.writer.writeln("use std::collections::HashMap;");
        self.writer.newline();

        // Constants and types
        self.writer
            .writeln("/// Register file: r0-r15, sp, fp, lr, pc, csp, cfp, reserved, zero");
        self.writer.writeln("const NUM_REGS: usize = 32;");
        self.writer
            .writeln("const MEMORY_SIZE: usize = 1024 * 1024; // 1MB");
        self.writer.newline();

        // Memory access helpers
        self.writer
            .writeln("/// Safe memory load with bounds checking");
        self.writer
            .writeln("fn load8(memory: &[u8], addr: u64) -> u64 {");
        self.writer.indent();
        self.writer
            .writeln("memory.get(addr as usize).copied().unwrap_or(0) as u64");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        self.writer
            .writeln("fn load16(memory: &[u8], addr: u64) -> u64 {");
        self.writer.indent();
        self.writer.writeln("let addr = addr as usize;");
        self.writer.writeln("if addr + 1 < memory.len() {");
        self.writer.indent();
        self.writer
            .writeln("u16::from_le_bytes([memory[addr], memory[addr + 1]]) as u64");
        self.writer.dedent();
        self.writer.writeln("} else { 0 }");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        self.writer
            .writeln("fn load32(memory: &[u8], addr: u64) -> u64 {");
        self.writer.indent();
        self.writer.writeln("let addr = addr as usize;");
        self.writer.writeln("if addr + 3 < memory.len() {");
        self.writer.indent();
        self.writer
            .writeln("u32::from_le_bytes(memory[addr..addr+4].try_into().unwrap()) as u64");
        self.writer.dedent();
        self.writer.writeln("} else { 0 }");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        self.writer
            .writeln("fn load64(memory: &[u8], addr: u64) -> u64 {");
        self.writer.indent();
        self.writer.writeln("let addr = addr as usize;");
        self.writer.writeln("if addr + 7 < memory.len() {");
        self.writer.indent();
        self.writer
            .writeln("u64::from_le_bytes(memory[addr..addr+8].try_into().unwrap())");
        self.writer.dedent();
        self.writer.writeln("} else { 0 }");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        self.writer
            .writeln("fn store8(memory: &mut [u8], addr: u64, val: u64) {");
        self.writer.indent();
        self.writer
            .writeln("if let Some(cell) = memory.get_mut(addr as usize) {");
        self.writer.indent();
        self.writer.writeln("*cell = val as u8;");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        self.writer
            .writeln("fn store16(memory: &mut [u8], addr: u64, val: u64) {");
        self.writer.indent();
        self.writer.writeln("let addr = addr as usize;");
        self.writer.writeln("if addr + 1 < memory.len() {");
        self.writer.indent();
        self.writer
            .writeln("memory[addr..addr+2].copy_from_slice(&(val as u16).to_le_bytes());");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        self.writer
            .writeln("fn store32(memory: &mut [u8], addr: u64, val: u64) {");
        self.writer.indent();
        self.writer.writeln("let addr = addr as usize;");
        self.writer.writeln("if addr + 3 < memory.len() {");
        self.writer.indent();
        self.writer
            .writeln("memory[addr..addr+4].copy_from_slice(&(val as u32).to_le_bytes());");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        self.writer
            .writeln("fn store64(memory: &mut [u8], addr: u64, val: u64) {");
        self.writer.indent();
        self.writer.writeln("let addr = addr as usize;");
        self.writer.writeln("if addr + 7 < memory.len() {");
        self.writer.indent();
        self.writer
            .writeln("memory[addr..addr+8].copy_from_slice(&val.to_le_bytes());");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        // Execution function
        self.writer
            .writeln("fn execute(regs: &mut [u64; NUM_REGS], memory: &mut [u8]) -> u64 {");
        self.writer.indent();

        Ok(())
    }

    fn emit_epilogue(&mut self) -> CodeGenResult<()> {
        self.writer.writeln("regs[0]");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.newline();

        // Main function
        self.writer.writeln("fn main() {");
        self.writer.indent();
        self.writer.writeln("// Initialize registers and memory");
        self.writer.writeln("let mut regs = [0u64; NUM_REGS];");
        self.writer
            .writeln("let mut memory = vec![0u8; MEMORY_SIZE];");
        self.writer.newline();
        self.writer.writeln("// Initialize stack pointer");
        self.writer
            .writeln("regs[16] = (MEMORY_SIZE - 8) as u64; // sp");
        self.writer.newline();
        self.writer.writeln("// Execute program");
        self.writer
            .writeln("let result = execute(&mut regs, &mut memory);");
        self.writer.newline();
        self.writer.writeln("// Exit with r0 as code");
        self.writer.writeln("std::process::exit(result as i32);");
        self.writer.dedent();
        self.writer.writeln("}");

        Ok(())
    }

    fn emit_instruction(&mut self, instr: &Instruction, index: usize) -> CodeGenResult<()> {
        // Emit label if this is a branch target
        if self.context.is_branch_target(index) {
            self.writer.dedent();
            self.writer.writeln(&format!("'L{}: loop {{", index));
            self.writer.indent();
        }

        match instr.opcode {
            Opcode::Alu => {
                let op = AluOp::from_u8(instr.mode).unwrap_or(AluOp::Add);
                self.emit_alu(op, instr.rd, instr.rs1, instr.rs2)?;
            }
            Opcode::AluI => {
                let op = AluOp::from_u8(instr.mode).unwrap_or(AluOp::Add);
                let imm = instr.imm.ok_or(CodeGenError::MissingImmediate(index))?;
                self.emit_alu_imm(op, instr.rd, instr.rs1, imm)?;
            }
            Opcode::MulDiv => {
                let op = MulDivOp::from_u8(instr.mode).unwrap_or(MulDivOp::Mul);
                self.emit_muldiv(op, instr.rd, instr.rs1, instr.rs2)?;
            }
            Opcode::Load => {
                let width = MemWidth::from_u8(instr.mode).unwrap_or(MemWidth::Double);
                let offset = instr.imm.unwrap_or(0);
                self.emit_load(width, instr.rd, instr.rs1, offset)?;
            }
            Opcode::Store => {
                let width = MemWidth::from_u8(instr.mode).unwrap_or(MemWidth::Double);
                let offset = instr.imm.unwrap_or(0);
                self.emit_store(width, instr.rd, instr.rs1, offset)?;
            }
            Opcode::Atomic => {
                let op = AtomicOp::from_u8(instr.mode).unwrap_or(AtomicOp::Cas);
                self.emit_atomic(op, instr.rd, instr.rs1, instr.rs2)?;
            }
            Opcode::Branch => {
                let cond = BranchCond::from_u8(instr.mode).unwrap_or(BranchCond::Always);
                let target = instr.imm.unwrap_or(0);
                self.emit_branch(cond, instr.rs1, instr.rs2, target)?;
            }
            Opcode::Call => {
                let target = instr.imm.unwrap_or(0);
                self.emit_call(target)?;
            }
            Opcode::Ret => self.emit_ret()?,
            Opcode::Jump => {
                let target = instr.imm.unwrap_or(0);
                self.emit_jump(target, instr.mode == 1)?;
            }
            Opcode::CapNew => self.emit_cap_new(instr.rd, instr.rs1, instr.rs2)?,
            Opcode::CapRestrict => self.emit_cap_restrict(instr.rd, instr.rs1, instr.rs2)?,
            Opcode::CapQuery => {
                let query = instr.imm.unwrap_or(0);
                self.emit_cap_query(instr.rd, instr.rs1, query)?;
            }
            Opcode::Spawn => {
                let target = instr.imm.unwrap_or(0);
                self.emit_spawn(instr.rd, target, instr.rs1)?;
            }
            Opcode::Join => self.emit_join(instr.rs1)?,
            Opcode::Chan => {
                let op = ChanOp::from_u8(instr.mode).unwrap_or(ChanOp::Create);
                self.emit_chan(op, instr.rd, instr.rs1)?;
            }
            Opcode::Fence => {
                let mode = FenceMode::from_u8(instr.mode).unwrap_or(FenceMode::SeqCst);
                self.emit_fence(mode)?;
            }
            Opcode::Yield => self.emit_yield()?,
            Opcode::Taint => self.emit_taint(instr.rd, instr.rs1)?,
            Opcode::Sanitize => self.emit_sanitize(instr.rd, instr.rs1)?,
            Opcode::File => {
                let op = FileOp::from_u8(instr.mode).unwrap_or(FileOp::Open);
                self.emit_file(op, instr.rd, instr.rs1, instr.rs2, instr.imm)?;
            }
            Opcode::Net => {
                let op = NetOp::from_u8(instr.mode).unwrap_or(NetOp::Socket);
                self.emit_net(op, instr.rd, instr.rs1, instr.rs2, instr.imm)?;
            }
            Opcode::NetSetopt => {
                self.writer.writeln(&format!(
                    "// net.setopt {} = {}",
                    self.reg(instr.rs1),
                    instr.imm.unwrap_or(0)
                ));
            }
            Opcode::Io => {
                let op = IoOp::from_u8(instr.mode).unwrap_or(IoOp::Print);
                self.emit_io(op, instr.rd, instr.rs1, instr.rs2)?;
            }
            Opcode::Time => {
                let op = TimeOp::from_u8(instr.mode).unwrap_or(TimeOp::Now);
                self.emit_time(op, instr.rd, instr.imm)?;
            }
            Opcode::Fpu => {
                let op = FpuOp::from_u8(instr.mode).unwrap_or(FpuOp::Fadd);
                self.emit_fpu(op, instr.rd, instr.rs1, instr.rs2)?;
            }
            Opcode::Rand => {
                let op = RandOp::from_u8(instr.mode).unwrap_or(RandOp::RandU64);
                self.emit_rand(op, instr.rd, instr.rs1)?;
            }
            Opcode::Bits => {
                let op = BitsOp::from_u8(instr.mode).unwrap_or(BitsOp::Popcount);
                self.emit_bits(op, instr.rd, instr.rs1)?;
            }
            Opcode::Mov => self.emit_mov(instr.rd, instr.rs1, instr.imm)?,
            Opcode::Trap => {
                let trap = TrapType::from_u8(instr.mode).unwrap_or(TrapType::User);
                self.emit_trap(trap, instr.imm)?;
            }
            Opcode::Nop => self.emit_nop()?,
            Opcode::Halt => self.emit_halt()?,
            Opcode::ExtCall => {
                let ext_id = instr.imm.unwrap_or(0);
                self.emit_ext_call(instr.rd, ext_id, instr.rs1, instr.rs2)?;
            }
        }

        Ok(())
    }

    fn emit_alu(
        &mut self,
        op: AluOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            match op {
                AluOp::Add => {
                    self.writer.writeln(&format!(
                        "{} = {}.wrapping_add({});",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                AluOp::Sub => {
                    self.writer.writeln(&format!(
                        "{} = {}.wrapping_sub({});",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                AluOp::Sar => {
                    self.writer.writeln(&format!(
                        "{} = (({} as i64) >> {}) as u64;",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                _ => {
                    let op_str = Self::alu_op_str(op);
                    self.writer.writeln(&format!(
                        "{} = {} {} {};",
                        dst,
                        self.reg(rs1),
                        op_str,
                        self.reg(rs2)
                    ));
                }
            }
        }
        Ok(())
    }

    fn emit_alu_imm(
        &mut self,
        op: AluOp,
        rd: Register,
        rs1: Register,
        imm: i32,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            match op {
                AluOp::Add => {
                    self.writer.writeln(&format!(
                        "{} = {}.wrapping_add({} as u64);",
                        dst,
                        self.reg(rs1),
                        imm
                    ));
                }
                AluOp::Sub => {
                    self.writer.writeln(&format!(
                        "{} = {}.wrapping_sub({} as u64);",
                        dst,
                        self.reg(rs1),
                        imm
                    ));
                }
                AluOp::Sar => {
                    self.writer.writeln(&format!(
                        "{} = (({} as i64) >> {}) as u64;",
                        dst,
                        self.reg(rs1),
                        imm
                    ));
                }
                _ => {
                    let op_str = Self::alu_op_str(op);
                    self.writer.writeln(&format!(
                        "{} = {} {} {};",
                        dst,
                        self.reg(rs1),
                        op_str,
                        format_number(imm)
                    ));
                }
            }
        }
        Ok(())
    }

    fn emit_muldiv(
        &mut self,
        op: MulDivOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            match op {
                MulDivOp::Mul => {
                    self.writer.writeln(&format!(
                        "{} = {}.wrapping_mul({});",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                MulDivOp::MulH => {
                    self.writer.writeln(&format!(
                        "{} = (({} as u128).wrapping_mul({} as u128) >> 64) as u64;",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                MulDivOp::Div => {
                    self.writer.writeln(&format!(
                        "{} = if {} != 0 {{ {} / {} }} else {{ 0 }};",
                        dst,
                        self.reg(rs2),
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                MulDivOp::Mod => {
                    self.writer.writeln(&format!(
                        "{} = if {} != 0 {{ {} % {} }} else {{ 0 }};",
                        dst,
                        self.reg(rs2),
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
            }
        }
        Ok(())
    }

    fn emit_load(
        &mut self,
        width: MemWidth,
        rd: Register,
        base: Register,
        offset: i32,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            let func = match width {
                MemWidth::Byte => "load8",
                MemWidth::Half => "load16",
                MemWidth::Word => "load32",
                MemWidth::Double => "load64",
            };
            if offset != 0 {
                self.writer.writeln(&format!(
                    "{} = {}(memory, {}.wrapping_add({} as u64));",
                    dst,
                    func,
                    self.reg(base),
                    offset
                ));
            } else {
                self.writer
                    .writeln(&format!("{} = {}(memory, {});", dst, func, self.reg(base)));
            }
        }
        Ok(())
    }

    fn emit_store(
        &mut self,
        width: MemWidth,
        src: Register,
        base: Register,
        offset: i32,
    ) -> CodeGenResult<()> {
        let func = match width {
            MemWidth::Byte => "store8",
            MemWidth::Half => "store16",
            MemWidth::Word => "store32",
            MemWidth::Double => "store64",
        };
        if offset != 0 {
            self.writer.writeln(&format!(
                "{}(memory, {}.wrapping_add({} as u64), {});",
                func,
                self.reg(base),
                offset,
                self.reg(src)
            ));
        } else {
            self.writer.writeln(&format!(
                "{}(memory, {}, {});",
                func,
                self.reg(base),
                self.reg(src)
            ));
        }
        Ok(())
    }

    fn emit_atomic(
        &mut self,
        op: AtomicOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
    ) -> CodeGenResult<()> {
        match op {
            AtomicOp::Cas => {
                if let Some(dst) = self.reg_assign(rd) {
                    let addr = self.reg(rs1);
                    let expected = self.reg(rs2);
                    self.writer.writeln(&format!(
                        "// atomic.cas: addr {}, expected {}, new {}",
                        addr, expected, dst
                    ));
                    self.writer.writeln("unsafe {");
                    self.writer.indent();
                    self.writer
                        .writeln(&format!("let atomic_ptr = {} as *mut AtomicU64;", addr));
                    self.writer.writeln("if !atomic_ptr.is_null() {");
                    self.writer.indent();
                    self.writer.writeln(&format!("let old_val = {};", dst));
                    self.writer.writeln(&format!(
                        "{} = (*atomic_ptr).compare_exchange({}, old_val, Ordering::SeqCst, Ordering::SeqCst).unwrap_or_else(|x| x);",
                        dst, expected
                    ));
                    self.writer.dedent();
                    self.writer.writeln("}");
                    self.writer.dedent();
                    self.writer.writeln("}");
                }
            }
            AtomicOp::Xchg => {
                if let Some(dst) = self.reg_assign(rd) {
                    let addr = self.reg(rs1);
                    let new_val = self.reg(rs2);
                    self.writer
                        .writeln(&format!("// atomic.swap: addr {}, new {}", addr, new_val));
                    self.writer.writeln("unsafe {");
                    self.writer.indent();
                    self.writer
                        .writeln(&format!("let atomic_ptr = {} as *mut AtomicU64;", addr));
                    self.writer
                        .writeln(&format!("{} = if !atomic_ptr.is_null() {{", dst));
                    self.writer.indent();
                    self.writer.writeln(&format!(
                        "(*atomic_ptr).swap({}, Ordering::SeqCst)",
                        new_val
                    ));
                    self.writer.dedent();
                    self.writer.writeln("} else { 0 };");
                    self.writer.dedent();
                    self.writer.writeln("}");
                }
            }
            AtomicOp::Add => {
                if let Some(dst) = self.reg_assign(rd) {
                    let addr = self.reg(rs1);
                    let val = self.reg(rs2);
                    self.writer
                        .writeln(&format!("// atomic.add: addr {}, val {}", addr, val));
                    self.writer.writeln("unsafe {");
                    self.writer.indent();
                    self.writer
                        .writeln(&format!("let atomic_ptr = {} as *mut AtomicU64;", addr));
                    self.writer
                        .writeln(&format!("{} = if !atomic_ptr.is_null() {{", dst));
                    self.writer.indent();
                    self.writer.writeln(&format!(
                        "(*atomic_ptr).fetch_add({}, Ordering::SeqCst)",
                        val
                    ));
                    self.writer.dedent();
                    self.writer.writeln("} else { 0 };");
                    self.writer.dedent();
                    self.writer.writeln("}");
                }
            }
            AtomicOp::Min => {
                if let Some(dst) = self.reg_assign(rd) {
                    let addr = self.reg(rs1);
                    let val = self.reg(rs2);
                    self.writer
                        .writeln(&format!("// atomic.min: addr {}, val {}", addr, val));
                    self.writer.writeln("unsafe {");
                    self.writer.indent();
                    self.writer
                        .writeln(&format!("let atomic_ptr = {} as *mut AtomicU64;", addr));
                    self.writer
                        .writeln(&format!("{} = if !atomic_ptr.is_null() {{", dst));
                    self.writer.indent();
                    self.writer.writeln("loop {");
                    self.writer.indent();
                    self.writer
                        .writeln("let current = (*atomic_ptr).load(Ordering::SeqCst);");
                    self.writer
                        .writeln(&format!("let new_val = current.min({});", val));
                    self.writer.writeln("match (*atomic_ptr).compare_exchange(current, new_val, Ordering::SeqCst, Ordering::SeqCst) {");
                    self.writer.indent();
                    self.writer.writeln("Ok(v) => break v,");
                    self.writer.writeln("Err(_) => continue,");
                    self.writer.dedent();
                    self.writer.writeln("}");
                    self.writer.dedent();
                    self.writer.writeln("}");
                    self.writer.dedent();
                    self.writer.writeln("} else { 0 };");
                    self.writer.dedent();
                    self.writer.writeln("}");
                }
            }
            AtomicOp::Max => {
                if let Some(dst) = self.reg_assign(rd) {
                    let addr = self.reg(rs1);
                    let val = self.reg(rs2);
                    self.writer
                        .writeln(&format!("// atomic.max: addr {}, val {}", addr, val));
                    self.writer.writeln("unsafe {");
                    self.writer.indent();
                    self.writer
                        .writeln(&format!("let atomic_ptr = {} as *mut AtomicU64;", addr));
                    self.writer
                        .writeln(&format!("{} = if !atomic_ptr.is_null() {{", dst));
                    self.writer.indent();
                    self.writer.writeln("loop {");
                    self.writer.indent();
                    self.writer
                        .writeln("let current = (*atomic_ptr).load(Ordering::SeqCst);");
                    self.writer
                        .writeln(&format!("let new_val = current.max({});", val));
                    self.writer.writeln("match (*atomic_ptr).compare_exchange(current, new_val, Ordering::SeqCst, Ordering::SeqCst) {");
                    self.writer.indent();
                    self.writer.writeln("Ok(v) => break v,");
                    self.writer.writeln("Err(_) => continue,");
                    self.writer.dedent();
                    self.writer.writeln("}");
                    self.writer.dedent();
                    self.writer.writeln("}");
                    self.writer.dedent();
                    self.writer.writeln("} else { 0 };");
                    self.writer.dedent();
                    self.writer.writeln("}");
                }
            }
            _ => {
                self.writer.writeln(&format!(
                    "// atomic.{:?} rd={}, rs1={}, rs2={}",
                    op,
                    register_name(rd),
                    self.reg(rs1),
                    self.reg(rs2)
                ));
                self.writer
                    .writeln("std::sync::atomic::fence(Ordering::SeqCst);");
            }
        }
        Ok(())
    }

    fn emit_branch(
        &mut self,
        cond: BranchCond,
        rs1: Register,
        rs2: Register,
        target: i32,
    ) -> CodeGenResult<()> {
        let target_index = (self.context.current_index as i32 + target) as usize;
        self.context.mark_branch_target(target_index);

        match cond {
            BranchCond::Always => {
                self.writer
                    .writeln(&format!("continue 'L{};", target_index));
            }
            BranchCond::Ltu => {
                self.writer.writeln(&format!(
                    "if {} < {} {{ continue 'L{}; }}",
                    self.reg(rs1),
                    self.reg(rs2),
                    target_index
                ));
            }
            _ => {
                let op = Self::branch_cond_str(cond);
                self.writer.writeln(&format!(
                    "if ({} as i64) {} ({} as i64) {{ continue 'L{}; }}",
                    self.reg(rs1),
                    op,
                    self.reg(rs2),
                    target_index
                ));
            }
        }
        Ok(())
    }

    fn emit_call(&mut self, target: i32) -> CodeGenResult<()> {
        let target_index = (self.context.current_index as i32 + target) as usize;
        self.context.mark_branch_target(target_index);
        self.writer.writeln(&format!(
            "regs[18] = {}; // save return address to lr",
            self.context.current_index + 1
        ));
        self.writer
            .writeln(&format!("continue 'L{};", target_index));
        Ok(())
    }

    fn emit_ret(&mut self) -> CodeGenResult<()> {
        self.writer.writeln("return regs[0]; // ret");
        Ok(())
    }

    fn emit_jump(&mut self, target: i32, indirect: bool) -> CodeGenResult<()> {
        if indirect {
            self.writer.writeln("// indirect jump not fully supported");
            self.writer.writeln("return regs[0];");
        } else {
            let target_index = (self.context.current_index as i32 + target) as usize;
            self.context.mark_branch_target(target_index);
            self.writer
                .writeln(&format!("continue 'L{};", target_index));
        }
        Ok(())
    }

    fn emit_cap_new(&mut self, rd: Register, base: Register, len: Register) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            self.writer
                .writeln(&format!("{} = {}; // cap.new", dst, self.reg(base)));
        }
        let _ = len;
        Ok(())
    }

    fn emit_cap_restrict(
        &mut self,
        rd: Register,
        src: Register,
        len: Register,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            self.writer
                .writeln(&format!("{} = {}; // cap.restrict", dst, self.reg(src)));
        }
        let _ = len;
        Ok(())
    }

    fn emit_cap_query(
        &mut self,
        rd: Register,
        cap: Register,
        query_type: i32,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            self.writer.writeln(&format!(
                "{} = {}; // cap.query type={}",
                dst,
                self.reg(cap),
                query_type
            ));
        }
        Ok(())
    }

    fn emit_spawn(&mut self, rd: Register, target: i32, arg: Register) -> CodeGenResult<()> {
        let target_index = (self.context.current_index as i32 + target) as usize;
        self.writer
            .writeln(&format!("// spawn: create thread for L{}", target_index));
        if let Some(dst) = self.reg_assign(rd) {
            self.writer
                .writeln(&format!("let arg_val = {};", self.reg(arg)));
            self.writer
                .writeln("let handle = std::thread::spawn(move || {");
            self.writer.indent();
            self.writer.writeln("// Thread execution context");
            self.writer
                .writeln("let mut thread_regs = [0u64; NUM_REGS];");
            self.writer.writeln("thread_regs[0] = arg_val;");
            self.writer
                .writeln(&format!("// Would jump to L{}", target_index));
            self.writer.writeln("0u64 // return value");
            self.writer.dedent();
            self.writer.writeln("});");
            self.writer.writeln(&format!(
                "{} = Box::into_raw(Box::new(handle)) as u64; // store handle as task ID",
                dst
            ));
        }
        Ok(())
    }

    fn emit_join(&mut self, task: Register) -> CodeGenResult<()> {
        self.writer
            .writeln(&format!("// join: waiting for task {}", self.reg(task)));
        self.writer.writeln("unsafe {");
        self.writer.indent();
        self.writer.writeln(&format!(
            "let handle_ptr = {} as *mut JoinHandle<u64>;",
            self.reg(task)
        ));
        self.writer.writeln("if !handle_ptr.is_null() {");
        self.writer.indent();
        self.writer
            .writeln("let handle = Box::from_raw(handle_ptr);");
        self.writer.writeln("let _ = handle.join().unwrap();");
        self.writer.dedent();
        self.writer.writeln("}");
        self.writer.dedent();
        self.writer.writeln("}");
        Ok(())
    }

    fn emit_chan(&mut self, op: ChanOp, rd: Register, rs1: Register) -> CodeGenResult<()> {
        match op {
            ChanOp::Create => {
                if let Some(dst) = self.reg_assign(rd) {
                    let buf_size = self.reg(rs1);
                    self.writer
                        .writeln(&format!("// chan.create: buffer size {}", buf_size));
                    self.writer
                        .writeln(&format!("let (tx, rx) = if {} > 0 {{", buf_size));
                    self.writer.indent();
                    self.writer
                        .writeln(&format!("mpsc::sync_channel({} as usize)", buf_size));
                    self.writer.dedent();
                    self.writer.writeln("} else {");
                    self.writer.indent();
                    self.writer.writeln("mpsc::channel()");
                    self.writer.dedent();
                    self.writer.writeln("};");
                    self.writer.writeln(&format!(
                        "{} = Box::into_raw(Box::new((tx, rx))) as u64; // store channel handle",
                        dst
                    ));
                }
            }
            ChanOp::Send => {
                let chan = self.reg(rd);
                let value = self.reg(rs1);
                self.writer.writeln(&format!(
                    "// chan.send: value {} to channel {}",
                    value, chan
                ));
                self.writer.writeln("unsafe {");
                self.writer.indent();
                self.writer.writeln(&format!(
                    "let chan_ptr = {} as *mut (Sender<u64>, Receiver<u64>);",
                    chan
                ));
                self.writer.writeln("if !chan_ptr.is_null() {");
                self.writer.indent();
                self.writer
                    .writeln(&format!("(*chan_ptr).0.send({}).unwrap();", value));
                self.writer.dedent();
                self.writer.writeln("}");
                self.writer.dedent();
                self.writer.writeln("}");
            }
            ChanOp::Recv => {
                if let Some(dst) = self.reg_assign(rd) {
                    let chan = self.reg(rs1);
                    self.writer
                        .writeln(&format!("// chan.recv: from channel {}", chan));
                    self.writer.writeln("unsafe {");
                    self.writer.indent();
                    self.writer.writeln(&format!(
                        "let chan_ptr = {} as *mut (Sender<u64>, Receiver<u64>);",
                        chan
                    ));
                    self.writer
                        .writeln(&format!("{} = if !chan_ptr.is_null() {{", dst));
                    self.writer.indent();
                    self.writer.writeln("(*chan_ptr).1.recv().unwrap()");
                    self.writer.dedent();
                    self.writer.writeln("} else { 0 };");
                    self.writer.dedent();
                    self.writer.writeln("}");
                }
            }
            ChanOp::Close => {
                let chan = self.reg(rd);
                self.writer
                    .writeln(&format!("// chan.close: channel {}", chan));
                self.writer.writeln("unsafe {");
                self.writer.indent();
                self.writer.writeln(&format!(
                    "let chan_ptr = {} as *mut (Sender<u64>, Receiver<u64>);",
                    chan
                ));
                self.writer.writeln("if !chan_ptr.is_null() {");
                self.writer.indent();
                self.writer
                    .writeln("let _ = Box::from_raw(chan_ptr); // drop sender");
                self.writer.dedent();
                self.writer.writeln("}");
                self.writer.dedent();
                self.writer.writeln("}");
            }
        }
        Ok(())
    }

    fn emit_fence(&mut self, mode: FenceMode) -> CodeGenResult<()> {
        let order = match mode {
            FenceMode::Acquire => "Ordering::Acquire",
            FenceMode::Release => "Ordering::Release",
            FenceMode::AcqRel => "Ordering::AcqRel",
            FenceMode::SeqCst => "Ordering::SeqCst",
        };
        self.writer
            .writeln(&format!("std::sync::atomic::fence({});", order));
        Ok(())
    }

    fn emit_yield(&mut self) -> CodeGenResult<()> {
        self.writer.writeln("std::thread::yield_now();");
        Ok(())
    }

    fn emit_taint(&mut self, rd: Register, rs1: Register) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            self.writer
                .writeln(&format!("{} = {}; // taint", dst, self.reg(rs1)));
        }
        Ok(())
    }

    fn emit_sanitize(&mut self, rd: Register, rs1: Register) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            self.writer
                .writeln(&format!("{} = {}; // sanitize", dst, self.reg(rs1)));
        }
        Ok(())
    }

    fn emit_file(
        &mut self,
        op: FileOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
        imm: Option<i32>,
    ) -> CodeGenResult<()> {
        match op {
            FileOp::Open => {
                if let Some(dst) = self.reg_assign(rd) {
                    let path_ptr = self.reg(rs1);
                    let flags = self.reg(rs2);
                    self.writer.writeln(&format!(
                        "// file.open: path ptr {}, flags {}",
                        path_ptr, flags
                    ));
                    self.writer
                        .writeln(&format!("{} = 0; // file descriptor placeholder", dst));
                }
            }
            FileOp::Read => {
                if let Some(dst) = self.reg_assign(rd) {
                    let fd = self.reg(rs1);
                    let buf_ptr = self.reg(rs2);
                    let len = imm.unwrap_or(0);
                    self.writer.writeln(&format!(
                        "// file.read: fd {}, buffer {}, len {}",
                        fd, buf_ptr, len
                    ));
                    self.writer
                        .writeln(&format!("{} = 0; // bytes read placeholder", dst));
                }
            }
            FileOp::Write => {
                if let Some(dst) = self.reg_assign(rd) {
                    let fd = self.reg(rs1);
                    let buf_ptr = self.reg(rs2);
                    let len = imm.unwrap_or(0);
                    self.writer.writeln(&format!(
                        "// file.write: fd {}, buffer {}, len {}",
                        fd, buf_ptr, len
                    ));
                    self.writer
                        .writeln(&format!("{} = 0; // bytes written placeholder", dst));
                }
            }
            FileOp::Close => {
                let fd = self.reg(rd);
                self.writer.writeln(&format!("// file.close: fd {}", fd));
            }
            FileOp::Seek => {
                if let Some(dst) = self.reg_assign(rd) {
                    let fd = self.reg(rs1);
                    let offset = self.reg(rs2);
                    self.writer
                        .writeln(&format!("// file.seek: fd {}, offset {}", fd, offset));
                    self.writer.writeln("unsafe {");
                    self.writer.indent();
                    self.writer
                        .writeln(&format!("let file_ptr = {} as *mut File;", fd));
                    self.writer
                        .writeln(&format!("{} = if !file_ptr.is_null() {{", dst));
                    self.writer.indent();
                    self.writer.writeln(&format!(
                        "(*file_ptr).seek(SeekFrom::Start({} as u64)).unwrap_or(0)",
                        offset
                    ));
                    self.writer.dedent();
                    self.writer.writeln("} else { 0 };");
                    self.writer.dedent();
                    self.writer.writeln("}");
                }
            }
            FileOp::Stat => {
                if let Some(dst) = self.reg_assign(rd) {
                    let path_ptr = self.reg(rs1);
                    self.writer
                        .writeln(&format!("// file.stat: path ptr {}", path_ptr));
                    self.writer.writeln(&format!(
                        "{} = 0; // stat result placeholder (use fs::metadata)",
                        dst
                    ));
                }
            }
            FileOp::Mkdir => {
                if let Some(dst) = self.reg_assign(rd) {
                    let path_ptr = self.reg(rs1);
                    self.writer
                        .writeln(&format!("// file.mkdir: path ptr {}", path_ptr));
                    self.writer.writeln(&format!(
                        "{} = 0; // mkdir result placeholder (use fs::create_dir_all)",
                        dst
                    ));
                }
            }
            FileOp::Delete => {
                if let Some(dst) = self.reg_assign(rd) {
                    let path_ptr = self.reg(rs1);
                    self.writer
                        .writeln(&format!("// file.delete: path ptr {}", path_ptr));
                    self.writer.writeln(&format!(
                        "{} = 0; // delete result placeholder (use fs::remove_file)",
                        dst
                    ));
                }
            }
        }
        Ok(())
    }

    fn emit_net(
        &mut self,
        op: NetOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
        imm: Option<i32>,
    ) -> CodeGenResult<()> {
        match op {
            NetOp::Socket => {
                if let Some(dst) = self.reg_assign(rd) {
                    let family = self.reg(rs1);
                    let sock_type = self.reg(rs2);
                    self.writer.writeln(&format!(
                        "// net.socket: family {}, type {}",
                        family, sock_type
                    ));
                    self.writer
                        .writeln(&format!("{} = 0; // socket descriptor placeholder", dst));
                }
            }
            NetOp::Connect => {
                if let Some(dst) = self.reg_assign(rd) {
                    let sock = self.reg(rs1);
                    let addr_ptr = self.reg(rs2);
                    self.writer.writeln(&format!(
                        "// net.connect: socket {}, addr ptr {}",
                        sock, addr_ptr
                    ));
                    self.writer.writeln(&format!(
                        "{} = 0; // connect result (use TcpStream::connect)",
                        dst
                    ));
                }
            }
            NetOp::Bind => {
                if let Some(dst) = self.reg_assign(rd) {
                    let sock = self.reg(rs1);
                    let addr_ptr = self.reg(rs2);
                    self.writer.writeln(&format!(
                        "// net.bind: socket {}, addr ptr {}",
                        sock, addr_ptr
                    ));
                    self.writer.writeln(&format!(
                        "{} = 0; // bind result (use TcpListener::bind)",
                        dst
                    ));
                }
            }
            NetOp::Listen => {
                if let Some(dst) = self.reg_assign(rd) {
                    let sock = self.reg(rs1);
                    let backlog = self.reg(rs2);
                    self.writer.writeln(&format!(
                        "// net.listen: socket {}, backlog {}",
                        sock, backlog
                    ));
                    self.writer
                        .writeln(&format!("{} = 0; // listen result", dst));
                }
            }
            NetOp::Accept => {
                if let Some(dst) = self.reg_assign(rd) {
                    let sock = self.reg(rs1);
                    self.writer
                        .writeln(&format!("// net.accept: socket {}", sock));
                    self.writer.writeln("unsafe {");
                    self.writer.indent();
                    self.writer
                        .writeln(&format!("let listener_ptr = {} as *mut TcpListener;", sock));
                    self.writer
                        .writeln(&format!("{} = if !listener_ptr.is_null() {{", dst));
                    self.writer.indent();
                    self.writer
                        .writeln("if let Ok((stream, _)) = (*listener_ptr).accept() {");
                    self.writer.indent();
                    self.writer
                        .writeln("Box::into_raw(Box::new(stream)) as u64");
                    self.writer.dedent();
                    self.writer.writeln("} else { 0 }");
                    self.writer.dedent();
                    self.writer.writeln("} else { 0 };");
                    self.writer.dedent();
                    self.writer.writeln("}");
                }
            }
            NetOp::Send => {
                if let Some(dst) = self.reg_assign(rd) {
                    let sock = self.reg(rs1);
                    let buf_ptr = self.reg(rs2);
                    let len = imm.unwrap_or(0);
                    self.writer.writeln(&format!(
                        "// net.send: socket {}, buffer {}, len {}",
                        sock, buf_ptr, len
                    ));
                    self.writer
                        .writeln(&format!("{} = 0; // bytes sent (use stream.write)", dst));
                }
            }
            NetOp::Recv => {
                if let Some(dst) = self.reg_assign(rd) {
                    let sock = self.reg(rs1);
                    let buf_ptr = self.reg(rs2);
                    let len = imm.unwrap_or(0);
                    self.writer.writeln(&format!(
                        "// net.recv: socket {}, buffer {}, len {}",
                        sock, buf_ptr, len
                    ));
                    self.writer
                        .writeln(&format!("{} = 0; // bytes received (use stream.read)", dst));
                }
            }
            NetOp::Close => {
                let sock = self.reg(rd);
                self.writer
                    .writeln(&format!("// net.close: socket {}", sock));
                self.writer.writeln("unsafe {");
                self.writer.indent();
                self.writer
                    .writeln(&format!("let stream_ptr = {} as *mut TcpStream;", sock));
                self.writer.writeln("if !stream_ptr.is_null() {");
                self.writer.indent();
                self.writer
                    .writeln("let _ = Box::from_raw(stream_ptr); // drop closes socket");
                self.writer.dedent();
                self.writer.writeln("}");
                self.writer.dedent();
                self.writer.writeln("}");
            }
        }
        Ok(())
    }

    fn emit_io(
        &mut self,
        op: IoOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
    ) -> CodeGenResult<()> {
        match op {
            IoOp::Print => {
                self.writer.writeln(&format!(
                    "{{ let start = {} as usize; let end = start + {} as usize; if end <= memory.len() {{ let _ = io::stdout().write_all(&memory[start..end]); }} }}",
                    self.reg(rs1), self.reg(rs2)
                ));
            }
            IoOp::GetArgs => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer
                        .writeln("// io.getargs: collect command-line arguments");
                    self.writer.writeln(&format!(
                        "{} = std::env::args().count() as u64; // argument count",
                        dst
                    ));
                }
            }
            IoOp::GetEnv => {
                if let Some(dst) = self.reg_assign(rd) {
                    let key_ptr = self.reg(rs1);
                    self.writer.writeln(&format!(
                        "// io.getenv: read environment variable (key ptr: {})",
                        key_ptr
                    ));
                    self.writer.writeln(&format!(
                        "{} = 0; // env value placeholder (use std::env::var)",
                        dst
                    ));
                }
            }
            _ => {
                self.writer
                    .writeln(&format!("// io.{:?} not implemented", op));
            }
        }
        Ok(())
    }

    fn emit_time(&mut self, op: TimeOp, rd: Register, imm: Option<i32>) -> CodeGenResult<()> {
        match op {
            TimeOp::Now => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!(
                        "{} = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();",
                        dst
                    ));
                }
            }
            TimeOp::Sleep => {
                let ms = imm.unwrap_or(0);
                self.writer.writeln(&format!(
                    "std::thread::sleep(Duration::from_millis({}));",
                    ms
                ));
            }
            TimeOp::Monotonic => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer.writeln(&format!(
                        "{} = Instant::now().elapsed().as_nanos() as u64;",
                        dst
                    ));
                }
            }
            _ => {}
        }
        Ok(())
    }

    fn emit_fpu(
        &mut self,
        op: FpuOp,
        rd: Register,
        rs1: Register,
        rs2: Register,
    ) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            match op {
                // Arithmetic operations return double bit pattern
                FpuOp::Fadd
                | FpuOp::Fsub
                | FpuOp::Fmul
                | FpuOp::Fdiv
                | FpuOp::Fsqrt
                | FpuOp::Fabs
                | FpuOp::Ffloor
                | FpuOp::Fceil => {
                    let expr = match op {
                        FpuOp::Fadd => format!(
                            "f64::from_bits({}) + f64::from_bits({})",
                            self.reg(rs1),
                            self.reg(rs2)
                        ),
                        FpuOp::Fsub => format!(
                            "f64::from_bits({}) - f64::from_bits({})",
                            self.reg(rs1),
                            self.reg(rs2)
                        ),
                        FpuOp::Fmul => format!(
                            "f64::from_bits({}) * f64::from_bits({})",
                            self.reg(rs1),
                            self.reg(rs2)
                        ),
                        FpuOp::Fdiv => format!(
                            "f64::from_bits({}) / f64::from_bits({})",
                            self.reg(rs1),
                            self.reg(rs2)
                        ),
                        FpuOp::Fsqrt => format!("f64::from_bits({}).sqrt()", self.reg(rs1)),
                        FpuOp::Fabs => format!("f64::from_bits({}).abs()", self.reg(rs1)),
                        FpuOp::Ffloor => format!("f64::from_bits({}).floor()", self.reg(rs1)),
                        FpuOp::Fceil => format!("f64::from_bits({}).ceil()", self.reg(rs1)),
                        _ => unreachable!(),
                    };
                    self.writer
                        .writeln(&format!("{} = ({}).to_bits();", dst, expr));
                }
                // Comparison operations return integer 1 or 0
                FpuOp::Fcmpeq => {
                    self.writer.writeln(&format!(
                        "{} = if f64::from_bits({}) == f64::from_bits({}) {{ 1 }} else {{ 0 }};",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                FpuOp::Fcmpne => {
                    self.writer.writeln(&format!(
                        "{} = if f64::from_bits({}) != f64::from_bits({}) {{ 1 }} else {{ 0 }};",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                FpuOp::Fcmplt => {
                    self.writer.writeln(&format!(
                        "{} = if f64::from_bits({}) < f64::from_bits({}) {{ 1 }} else {{ 0 }};",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                FpuOp::Fcmple => {
                    self.writer.writeln(&format!(
                        "{} = if f64::from_bits({}) <= f64::from_bits({}) {{ 1 }} else {{ 0 }};",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                FpuOp::Fcmpgt => {
                    self.writer.writeln(&format!(
                        "{} = if f64::from_bits({}) > f64::from_bits({}) {{ 1 }} else {{ 0 }};",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
                FpuOp::Fcmpge => {
                    self.writer.writeln(&format!(
                        "{} = if f64::from_bits({}) >= f64::from_bits({}) {{ 1 }} else {{ 0 }};",
                        dst,
                        self.reg(rs1),
                        self.reg(rs2)
                    ));
                }
            }
        }
        Ok(())
    }

    fn emit_rand(&mut self, op: RandOp, rd: Register, rs1: Register) -> CodeGenResult<()> {
        match op {
            RandOp::RandU64 => {
                if let Some(dst) = self.reg_assign(rd) {
                    self.writer
                        .writeln("// rand.u64: simple PRNG using system time");
                    self.writer.writeln("{");
                    self.writer.indent();
                    self.writer
                        .writeln("use std::collections::hash_map::RandomState;");
                    self.writer.writeln("use std::hash::{BuildHasher, Hasher};");
                    self.writer
                        .writeln("let random_state = RandomState::new();");
                    self.writer
                        .writeln("let mut hasher = random_state.build_hasher();");
                    self.writer.writeln("hasher.write_u64(SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as u64);");
                    self.writer.writeln(&format!("{} = hasher.finish();", dst));
                    self.writer.dedent();
                    self.writer.writeln("}");
                }
            }
            RandOp::RandBytes => {
                // rand.bytes: fill buffer at rs1 with random bytes, count in rd
                let buf = self.reg(rs1);
                let count = self.reg(rd);
                self.writer
                    .writeln(&format!("// rand.bytes: fill {} bytes at {}", count, buf));
                self.writer.writeln("{");
                self.writer.indent();
                self.writer
                    .writeln("use std::collections::hash_map::RandomState;");
                self.writer.writeln("use std::hash::{BuildHasher, Hasher};");
                self.writer
                    .writeln(&format!("let buf_addr = {} as usize;", buf));
                self.writer
                    .writeln(&format!("let count = {} as usize;", count));
                self.writer.writeln("if buf_addr + count <= memory.len() {");
                self.writer.indent();
                self.writer
                    .writeln("let random_state = RandomState::new();");
                self.writer.writeln("for i in 0..count {");
                self.writer.indent();
                self.writer
                    .writeln("let mut hasher = random_state.build_hasher();");
                self.writer.writeln("hasher.write_usize(i);");
                self.writer.writeln("hasher.write_u64(SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as u64);");
                self.writer
                    .writeln("memory[buf_addr + i] = hasher.finish() as u8;");
                self.writer.dedent();
                self.writer.writeln("}");
                self.writer.dedent();
                self.writer.writeln("}");
                self.writer.dedent();
                self.writer.writeln("}");
            }
        }
        Ok(())
    }

    fn emit_bits(&mut self, op: BitsOp, rd: Register, rs1: Register) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            let expr = match op {
                BitsOp::Popcount => format!("{}.count_ones() as u64", self.reg(rs1)),
                BitsOp::Clz => format!("{}.leading_zeros() as u64", self.reg(rs1)),
                BitsOp::Ctz => format!("{}.trailing_zeros() as u64", self.reg(rs1)),
                BitsOp::Bswap => format!("{}.swap_bytes()", self.reg(rs1)),
            };
            self.writer.writeln(&format!("{} = {};", dst, expr));
        }
        Ok(())
    }

    fn emit_mov(&mut self, rd: Register, rs1: Register, imm: Option<i32>) -> CodeGenResult<()> {
        if let Some(dst) = self.reg_assign(rd) {
            if rs1 != Register::Zero {
                self.writer
                    .writeln(&format!("{} = {};", dst, self.reg(rs1)));
            } else if let Some(i) = imm {
                self.writer.writeln(&format!("{} = {} as u64;", dst, i));
            } else {
                self.writer.writeln(&format!("{} = 0;", dst));
            }
        }
        Ok(())
    }

    fn emit_trap(&mut self, trap_type: TrapType, imm: Option<i32>) -> CodeGenResult<()> {
        let code = imm.unwrap_or(0);
        match trap_type {
            TrapType::DivByZero => {
                self.writer
                    .writeln("eprintln!(\"TRAP: Division by zero\");");
                self.writer.writeln("std::process::exit(1);");
            }
            TrapType::BoundsViolation => {
                self.writer
                    .writeln("eprintln!(\"TRAP: Bounds violation\");");
                self.writer.writeln("std::process::exit(2);");
            }
            TrapType::CapabilityViolation => {
                self.writer
                    .writeln("eprintln!(\"TRAP: Capability violation\");");
                self.writer.writeln("std::process::exit(3);");
            }
            TrapType::TaintViolation => {
                self.writer.writeln("eprintln!(\"TRAP: Taint violation\");");
                self.writer.writeln("std::process::exit(4);");
            }
            TrapType::InvalidOp => {
                self.writer
                    .writeln("eprintln!(\"TRAP: Invalid operation\");");
                self.writer.writeln("std::process::exit(5);");
            }
            TrapType::Syscall => {
                self.writer
                    .writeln(&format!("eprintln!(\"TRAP: Syscall (code: {})\");", code));
                self.writer
                    .writeln(&format!("std::process::exit({});", code.max(1)));
            }
            TrapType::Breakpoint => {
                self.writer.writeln(&format!(
                    "eprintln!(\"TRAP: Breakpoint (code: {})\");",
                    code
                ));
                self.writer.writeln("std::process::exit(0);");
            }
            TrapType::User => {
                self.writer.writeln(&format!(
                    "eprintln!(\"TRAP: User-defined trap (code: {})\");",
                    code
                ));
                self.writer
                    .writeln(&format!("std::process::exit({});", code.max(1)));
            }
        }
        Ok(())
    }

    fn emit_nop(&mut self) -> CodeGenResult<()> {
        self.writer.writeln("// nop");
        Ok(())
    }

    fn emit_halt(&mut self) -> CodeGenResult<()> {
        self.writer.writeln("return regs[0]; // halt");
        Ok(())
    }

    fn emit_ext_call(
        &mut self,
        rd: Register,
        ext_id: i32,
        rs1: Register,
        rs2: Register,
    ) -> CodeGenResult<()> {
        // External function call - invokes a function from an external library or runtime
        // ext_id: identifier of the external function to call
        // rs1, rs2: arguments passed to the external function
        // rd: destination register for the return value
        self.writer.writeln(&format!(
            "// ext.call: invoke external function {} with args ({}, {})",
            ext_id,
            self.reg(rs1),
            self.reg(rs2)
        ));
        self.writer
            .writeln("// External function calls would be implemented via FFI or dynamic linking");
        if let Some(dst) = self.reg_assign(rd) {
            self.writer
                .writeln(&format!("{} = 0; // return value placeholder", dst));
        }
        Ok(())
    }

    fn emit_label(&mut self, index: usize) -> CodeGenResult<()> {
        self.writer.writeln(&format!("'L{}:", index));
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::Assembler;

    #[test]
    fn test_rust_generator_simple() {
        let mut asm = Assembler::new();
        let program = asm.assemble("mov r0, 42\nhalt").unwrap();

        let mut gen = RustCodeGenerator::new();
        let code = gen.generate(&program).unwrap();

        assert!(code.contains("fn main()"));
        assert!(code.contains("regs[0] = 42"));
        assert!(code.contains("return regs[0]; // halt"));
    }
}
