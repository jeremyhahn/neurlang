# Neurlang Project Context

This file provides context for Claude Code when working on this project.

## Project Overview

Neurlang is an AI-optimized binary programming language with a custom ISA designed for 1000x faster code generation than traditional LLM approaches. The model generates 64 instruction slots in parallel, which are then compiled to native x86-64 via copy-and-patch compilation in ~5μs.

## Architecture

### Two-Tier Generation

1. **Small Fast Model** (~25M params): Generates 64 instruction slots in parallel
2. **RAG Resolution**: Maps intent descriptions to extension IDs
3. **Copy-and-Patch Compiler**: Compiles to native x86-64 in ~5μs

### Rust→IR Compiler (Key Architecture)

Rust is the **source of truth** for stdlib implementations:

```
stdlib/src/*.rs (Rust source - you write this)
       ↓
   nl stdlib build (Rust→IR compiler)
       ↓
lib/*.nl (generated Neurlang assembly - don't edit manually)
       ↓
Training data generator
       ↓
Model learns stdlib patterns
```

**Benefits:**
- Correctness is guaranteed (Rust is the oracle)
- Tests auto-generated by running Rust functions
- No manual maintenance of .nl files
- Model learns real implementation patterns

## Directory Structure

```
neurlang/
├── stdlib/                 # Rust source (EDIT THIS)
│   ├── Cargo.toml
│   └── src/
│       ├── lib.rs          # Module exports
│       ├── math.rs         # factorial, fibonacci, gcd, power, etc.
│       ├── float.rs        # FPU operations (sqrt, abs, floor, ceil)
│       ├── string.rs       # strlen, strcmp, strcpy, atoi, itoa
│       ├── array.rs        # sum, min, max, search, sort
│       ├── bitwise.rs      # popcount, clz, ctz, rotl, rotr
│       └── collections.rs  # stack, queue, hashtable
│
├── lib/                    # GENERATED (don't edit manually)
│   ├── math/               # 12 functions
│   ├── float/              # 20 functions
│   ├── string/             # 25 functions
│   ├── array/              # 22 functions
│   ├── bitwise/            # 16 functions
│   └── collections/        # 18 functions (113 total)
│
├── examples/               # Hand-written application examples
│   ├── algorithm/          # Algorithm examples
│   ├── application/        # Service examples (user, auth, etc.)
│   ├── network/            # TCP, HTTP, REST API servers
│   ├── patterns/           # Production patterns
│   │   ├── error-handling/ # Retry, circuit breaker, graceful degradation
│   │   ├── validation/     # Input sanitization, rate limiting, auth
│   │   ├── database/       # Transactions, connection pooling, migrations
│   │   ├── caching/        # LRU cache, cache-aside, invalidation
│   │   └── network/        # TLS, keep-alive, chunked transfer
│   ├── advanced/           # Complex composition patterns (difficulty 4-5)
│   │   ├── oauth2_flow.nl      # HTTP → JSON → crypto → state
│   │   ├── api_gateway.nl      # Auth → rate limit → route → proxy
│   │   ├── saga_pattern.nl     # Multi-step with compensations
│   │   └── ...
│   └── ...
│
├── src/
│   ├── compiler/           # Rust→IR compiler
│   │   ├── mod.rs
│   │   ├── parser.rs       # Parse Rust AST (via syn)
│   │   ├── analyzer.rs     # Type checking, scope
│   │   ├── codegen.rs      # Emit Neurlang IR
│   │   └── test_gen.rs     # Generate @test from Rust execution
│   ├── inference/          # RAG, embeddings, model inference
│   ├── ir/                 # Instruction representation
│   └── jit/                # Copy-and-patch compiler
│
├── train/
│   ├── generate_training_data.py  # Generates FROM lib/ and examples/
│   └── *.jsonl             # Generated training data
│
├── neurlang.toml           # Project configuration
└── models/                 # Trained model artifacts
```

## Configuration: neurlang.toml

```toml
[package]
name = "neurlang-stdlib"
version = "0.1.0"

[stdlib]
# Stdlib modules to include (compiled from Rust→IR)
math = true         # factorial, fibonacci, gcd, etc.
float = true        # sqrt, abs, floor, ceil
string = true       # strlen, atoi, itoa, etc.
array = true        # sum, reverse, search
bitwise = true      # popcount, clz, ctz
collections = true  # stack, queue, hashtable

[extensions.crates]
# Rust crates (from crates.io)
# serde_json = { version = "1.0" }
# regex = { version = "1.10" }

[extensions.go]
# Go packages
# golib = { package = "github.com/user/golib", tag = "v1.0.0" }

[extensions.c]
# C libraries
# zlib = { version = "1.3", system = true }

[build]
output_dir = "lib"
generate_tests = true
```

## Critical Conventions

### Training Data: Source of Truth

**RULE: All training data comes from verified sources:**
1. **lib/*.nl** - Generated from Rust stdlib (auto-tested)
2. **examples/*.nl** - Hand-written with @test annotations

```
WRONG: Generate synthetic instruction patterns
RIGHT: stdlib → Rust→IR compiler → lib/*.nl → training data
RIGHT: examples/ with @test → nl test → training data
```

### Adding Stdlib Functions

1. **Write Rust** in `stdlib/src/<module>.rs` with doc comment metadata:
```rust
/// Calculate factorial of n iteratively.
///
/// # Neurlang Export
/// - Category: algorithm/math
/// - Difficulty: 2
///
/// # Prompts
/// - compute factorial of {n}
/// - {n}!
/// - calculate {n} factorial
/// - what is {n}!
/// - factorial({n})
/// - multiply 1 * 2 * ... * {n}
/// - product of integers from 1 to {n}
///
/// # Parameters
/// - n=r0 "The number to compute factorial of"
///
/// # Test Cases
/// - factorial(0) = 1
/// - factorial(5) = 120
#[inline(never)]
pub fn factorial(n: u64) -> u64 {
    let mut result = 1u64;
    let mut i = n;
    while i > 0 {
        result *= i;
        i -= 1;
    }
    result
}
```

**Doc Comment Sections:**
- `# Neurlang Export`: Category and difficulty metadata
- `# Prompts`: 10-15 natural language variations with `{param}` placeholders
- `# Parameters`: `name=register "description"` format
- `# Test Cases`: `function(args) = result` format

2. **Build** with `nl stdlib --build`:
```bash
nl stdlib --build
# Generates lib/math/factorial.nl with @prompt, @param, @test annotations
```

3. **Verify** with `nl stdlib --verify`:
```bash
nl stdlib --verify
# Compares Rust output vs Neurlang output
```

### Generated .nl File Format

The compiler generates .nl files with full metadata annotations:

```asm
; @name: Factorial
; @description: Calculate factorial of n iteratively.
; @category: algorithm/math
; @difficulty: 2
;
; @prompt: compute factorial of {n}
; @prompt: {n}!
; @prompt: calculate {n} factorial
; @prompt: what is {n}!
; @prompt: factorial({n})
; ... (10-15 prompts per function)
;
; @param: n=r0 "The number to compute factorial of"
;
; @test: r0=0 -> r0=1
; @test: r0=1 -> r0=1
; @test: r0=5 -> r0=120
; @test: r0=10 -> r0=3628800
;
; @export: factorial
; Generated from Rust by nl stdlib build

.entry:
    mov r1, 1           ; result = 1
    mov r2, r0          ; i = n
.while_0:
    ...
```

**Annotation Reference:**
- `@name:` - Function name (from Rust function name)
- `@description:` - Description (from doc comment first line)
- `@category:` - Category for grouping (e.g., algorithm/math, string)
- `@difficulty:` - Complexity level (1-5)
- `@prompt:` - Natural language prompts with `{param}` placeholders for training
- `@param:` - Parameter docs: `name=register "description"`
- `@test:` - Test cases: `inputs -> outputs`
- `@export:` - Exported function name
- `@server: true` - Mark server examples (can't unit test)
- `@note:` - Document non-deterministic behavior

## Extension System Architecture

Neurlang has **four distinct layers** for code reuse. Understanding when to use each is critical:

```
┌─────────────────────────────────────────────────────────────────────────┐
│  TEMPLATES (templates/*.skeleton)                                        │
│  Application STRUCTURE - complete server/client patterns                 │
│  Use: "Build an SMTP server" → tcp_server.skeleton                       │
│  Location: templates/                                                    │
└─────────────────────────────────────────────────────────────────────────┘
                              ▼ uses
┌─────────────────────────────────────────────────────────────────────────┐
│  STDLIB (lib/*.nl)                                                       │
│  Pure Neurlang IR - model-generated, testable functions                  │
│  Use: strlen, factorial, quicksort, stack_push                           │
│  Location: lib/ (generated from stdlib/src/*.rs)                         │
└─────────────────────────────────────────────────────────────────────────┘
                              ▼ calls
┌─────────────────────────────────────────────────────────────────────────┐
│  EXTENSIONS (src/runtime/extensions.rs, src/runtime/stdlib/)             │
│  Rust FFI - complex operations, security-critical code                   │
│  Use: sha256, json_parse, http_get, aes_encrypt                          │
│  Called via: ext.call <id>, r0, r1, r2                                   │
└─────────────────────────────────────────────────────────────────────────┘
                              ▼ wraps
┌─────────────────────────────────────────────────────────────────────────┐
│  WRAPPERS (src/wrappers/*.rs)                                            │
│  High-level Rust APIs - convenience functions over extensions            │
│  Use: base64_encode, url_decode, tls_connect                             │
│  Internal use, exposed as extensions                                     │
└─────────────────────────────────────────────────────────────────────────┘
```

### Layer 1: Templates (templates/*.skeleton)

**Purpose**: Application-level patterns with slot placeholders

**When to use**: Building complete servers/clients from natural language

**Available templates**:
| Template | Use Case |
|----------|----------|
| `tcp_server.skeleton` | Line-based protocols (SMTP, FTP, Redis) |
| `udp_server.skeleton` | Datagram protocols (DNS, DHCP) |
| `unix_socket_server.skeleton` | IPC, local services |
| `http_server.skeleton` | Web servers |
| `rest_api.skeleton` | JSON REST APIs |
| `websocket_server.skeleton` | Real-time bidirectional |
| `json_rpc_server.skeleton` | JSON-RPC 2.0 services |
| `grpc_server.skeleton` | gRPC (requires extensions) |
| `mqtt_client.skeleton` | IoT pub/sub |

### Layer 2: Stdlib (lib/*.nl)

**Purpose**: Pure Neurlang IR functions the model generates

**When to use**: Algorithm implementations, data structures

**Source**: Generated from `stdlib/src/*.rs` via Rust→IR compiler

| Module | Functions | Examples |
|--------|-----------|----------|
| `lib/math/` | 12 | factorial, fibonacci, gcd, power |
| `lib/float/` | 22 | fsqrt, fabs, ffloor, fceil |
| `lib/string/` | 25+ | strlen, strcmp, strcpy, atoi |
| `lib/array/` | 22+ | sum, quicksort, binary_search |
| `lib/bitwise/` | 16 | popcount, clz, ctz, rotl |
| `lib/collections/` | 18+ | stack, queue, hashtable |

### Layer 3: Extensions (ext.call)

**Purpose**: Complex operations in Rust FFI

**When to use**: Crypto, JSON, HTTP, database, regex - anything too complex for IR

**Location**: `src/runtime/extensions.rs`, `src/runtime/stdlib/`

#### Extension ID Ranges

| Range | Category | Examples |
|-------|----------|----------|
| 1-99 | **Crypto** | sha1, sha256, sha384, sha512, aes, hmac |
| 100-119 | Vec operations | vec_new, vec_push, vec_pop |
| 120-139 | HashMap operations | hashmap_new, hashmap_get |
| 140-169 | String operations | string_new, string_concat |
| 170-189 | JSON operations | json_parse, json_get |
| 190-209 | HTTP client | http_get, http_post |
| 240-259 | File system | fs_read, fs_write |
| 260-279 | SQLite | sqlite_query |
| 280-299 | Regex | regex_match |
| 300-319 | DateTime | datetime_now |
| 330-339 | UUID | uuid_v4 |

#### Crypto Extensions (Complete List)

| ID | Name | Output | Description |
|----|------|--------|-------------|
| 38 | sha1 | 20 bytes | SHA-1 (WebSocket only!) |
| 1 | sha256 | 32 bytes | SHA-256 |
| 15 | sha384 | 48 bytes | SHA-384 |
| 16 | sha512 | 64 bytes | SHA-512 |
| 17 | sha3_256 | 32 bytes | SHA3-256 |
| 18 | sha3_512 | 64 bytes | SHA3-512 |
| 2 | hmac_sha256 | 32 bytes | HMAC-SHA256 |
| 21 | hmac_sha384 | 48 bytes | HMAC-SHA384 |
| 22 | hmac_sha512 | 64 bytes | HMAC-SHA512 |
| 3/4 | aes256_gcm | - | AES-256-GCM encrypt/decrypt |
| 11/12 | chacha20_poly1305 | - | ChaCha20 encrypt/decrypt |
| 8/9 | ed25519 | - | Ed25519 sign/verify |
| 35 | argon2id | - | Password hashing |

**Usage**:
```asm
; SHA-256 hash
lea r0, input_ptr       ; input
mov r1, input_len       ; length
lea r2, output_buf      ; 32-byte output
ext.call 1, r0, r1, r2  ; sha256

; JSON parse
lea r0, json_string
mov r1, json_len
ext.call 170, r0, r1    ; json_parse -> handle in r0
```

### Layer 4: Wrappers (src/wrappers/*.rs)

**Purpose**: High-level Rust utilities exposed as extensions

**When to use**: Internal - these wrap external crates

| Module | Functions |
|--------|-----------|
| `encoding.rs` | base64_encode, base64_decode, hex_encode, url_encode |
| `compression.rs` | gzip, deflate |
| `tls.rs` | tls_connect, https_get |
| `regex.rs` | regex_match, regex_replace |
| `datetime.rs` | datetime_now, datetime_format |
| `fs.rs` | fs_read, fs_write |

### Decision Guide: Which Layer?

| Need | Use | Why |
|------|-----|-----|
| Build SMTP server | **Template** | tcp_server.skeleton has the structure |
| Compute factorial | **Stdlib** | Pure algorithm, lib/math/factorial.nl |
| Parse JSON | **Extension** | Complex parsing, use json_parse (170) |
| Hash password | **Extension** | Security-critical, use argon2id (35) |
| SHA-256 hash | **Extension** | Crypto, use sha256 (1) |
| String length | **Stdlib** | Simple, lib/string/strlen.nl |
| HTTP request | **Extension** | Network I/O, use http_get (190) |
| Sort array | **Stdlib** | Algorithm, lib/array/quicksort.nl |
| Base64 encode | **Extension** | Encoding, via wrappers |
| WebSocket server | **Template** | websocket_server.skeleton |

### RAG Resolution

Extensions are resolved via RAG at assembly time:
```asm
; Model outputs intent description
ext.call @"parse JSON string", r0, r1

; RAG resolves to extension ID
ext.call 170, r0, r1  ; json_parse
```

## Register Conventions

- `r0`: Return value, primary accumulator
- `r0-r3`: Function arguments
- `r4-r9`: Caller-saved temporaries
- `r10-r15`: Callee-saved, server state
  - `r10`: Server socket FD
  - `r11`: Client socket FD
  - `r12`: Request/response length
  - `r14`: Database handle
- `r16-r31`: General purpose
- `zero`: Constant 0 (read-only)

## Commands Reference

### Build Commands

```bash
# Build the nl binary
cargo build --release

# Build stdlib from Rust sources
nl stdlib --build

# Verify Rust == Neurlang output
nl stdlib --verify
```

### Test Commands

```bash
# Test generated lib/ files
nl test -p lib

# Test hand-written examples
nl test -p examples

# Rust integration tests
cargo test --test integration_runner

# All Rust tests
cargo test
```

**IMPORTANT:** There's a known hang issue. Run nl commands with a timeout:
```bash
timeout 30s nl test -p examples
```

### Run Commands

```bash
# Run a program
nl run -i lib/math/factorial.nl

# Generate code from prompt
nl prompt "compute factorial of 5" --show-asm

# Assemble to binary
nl asm -i source.nl -o output.nlb
```

### Training Commands

```bash
# Generate ALL training data (unified generator - includes everything)
python train/generate_training_data.py train/training_data.jsonl

# Optional: Filter by difficulty level (1-5)
python train/generate_training_data.py train/training_data.jsonl --difficulty 4

# Optional: Filter by category
python train/generate_training_data.py train/training_data.jsonl --category network

# Combine filters
python train/generate_training_data.py train/training_data.jsonl --difficulty 4 --category patterns

# Train model (ON REMOTE GPU INSTANCE ONLY)
# DO NOT TRAIN LOCALLY
python train/train.py \
  --data train/training_data.jsonl \
  --epochs 50 \
  --batch-size 256 \
  --device cuda
```

**Training data sources:**
- `lib/*.nl` - Generated stdlib (primary, auto-tested)
- `examples/*.nl` - Hand-written with @test annotations
- Extension patterns - Crypto, JSON, HTTP, database compositions
- HTTP patterns - Protocol details, headers, status codes
- REST patterns - API endpoints, CRUD operations

## Rust Subset (Compiler Support)

### Tier 1: Core (Supported)
```rust
// Integer arithmetic
a + b, a - b, a * b, a / b, a % b

// Floating point (f64)
a + b, a - b, a * b, a / b
a.sqrt(), a.abs(), a.floor(), a.ceil()

// Bitwise
a & b, a | b, a ^ b, a << b, a >> b

// Comparisons
a == b, a != b, a < b, a <= b, a > b, a >= b

// Variables
let x = expr;
let mut x = expr;
x = expr;

// Control flow
if cond { ... } else { ... }
while cond { ... }
loop { ... break; }
for i in 0..n { ... }

// Functions
fn name(a: u64, b: u64) -> u64 { ... }
return expr;
```

### Out of Scope
- Heap allocation (use extensions)
- Generics/traits (use concrete types)
- Closures (use named functions)
- Async/await (use blocking calls)

## Debug vs Release Mode

| Aspect | Debug Mode | Release Mode |
|--------|------------|--------------|
| `ext.call` | Wrapper function | Direct impl call |
| Validation | Full bounds checking | None |
| Logging | Trace all calls | None |
| Error handling | Rich stack traces | Error code only |
| Performance | ~50-100ns overhead | ~0ns |

```bash
nl run program.nl --debug    # Development
nl run program.nl --release  # Production (default)
```

## Current Status

### Completed
- Rust→IR compiler (parser, analyzer, codegen, test_gen)
- stdlib with 113 generated functions across 6 modules (math, float, string, array, bitwise, collections)
- Compiler extracts `# Prompts`, `# Parameters`, `# Neurlang Export` from doc comments
- Generated .nl files include `@prompt`, `@param`, `@difficulty` annotations
- Training data generation with lib/ as primary source (deduplicates examples/)
- neurlang.toml configuration
- Multi-language extension architecture design

### In Progress
- Extension wrapper generation (`nl crate add`)
- Model training with stdlib patterns

## Code Quality

- All lib/*.nl files auto-tested (Rust is oracle)
- All examples must pass `nl test`
- All Rust tests must pass (`cargo test`)
- No untested/synthetic training data
- RAG knowledge base kept in sync with extensions
